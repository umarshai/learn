{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Professional Introduction","text":"<p>::: card</p>"},{"location":"#about-me","title":"\ud83d\udc4b About Me","text":"<p>Hi, my name is [Your Full Name]. I\u2019m from Andhra Pradesh and completed my B.Tech in 2019. I have 5.4 years of experience in IT and currently work as an Angular Developer at Accenture, Bangalore.</p>"},{"location":"#current-project","title":"\ud83d\udcbc Current Project","text":"<p>I\u2019m working on a project for Optum, a US-based healthcare organization in the insurance domain. The application provides a platform to: - Onboard clients - Enable clients to create their own micro-products - Manage their users efficiently - Basicallly we use micro front end technology with the help of single-spa-framework. which let our clients to crearte and use their m=own apps within our apps.</p>"},{"location":"#tech-stack","title":"Tech Stack:","text":"<ul> <li>Frontend: Angular (migrating to version 17)  </li> <li>Backend: Spring Boot  </li> </ul> <p>Our team of 8 members follows the Agile methodology, with two-week sprint cycles.</p>"},{"location":"#responsibilities","title":"\ud83d\udd27 Responsibilities","text":"<ul> <li>Feature Development: Collaborate with the UX team to develop new features from Figma designs.  </li> <li>Bug Fixing: Resolve defects identified during testing.  </li> <li>Production Support: Address and resolve production issues effectively.  </li> <li>Tools Used: </li> <li>Splunk for log analysis  </li> <li>Jenkins for deployments  </li> <li>SonarQube for code quality  </li> </ul> <p>:::</p>"},{"location":"check-list/","title":"CheckList","text":"Angular  <pre><code>        * Rxjs\n        * Sharing Data\n        * Forms\n        * Routing\n        * Core\n        * Pipes\n        * ngRx\n        * Optimization\n        * Best Practicces\n        * Testing\n        * Dynamic components\n        * New features\n        * ngRx\n</code></pre> JavaScript  <pre><code>    * concepts\n    * array methods\n    * string methods\n    * design patterns\n    * Solid principles\n    * oops\n</code></pre> Html  <pre><code>* New features\n* Accessibility\n* SEO \n</code></pre> Css  <pre><code>    * position\n    * center a div\n    * pseudo classes\n    * Flex, grid\n    * responsiveness\n    * sass\n    * Media Queries\n    * Material\n    * selectors\n</code></pre> DSA  <pre><code>    * DSA \n        - strings\n        - arrays\n        - objects\n    * Algorithms\n        - searching \n        - sorting\n</code></pre>"},{"location":"interview-exp/","title":"Frequently Asked Questions","text":""},{"location":"interview-exp/#value-labs","title":"value Labs","text":"1. challenges faced in Angular Migration (15 -&gt; 17)          Change Zone.js deep imports like zone.js/bundles/zone-testing.js and zone.js/dist/zone to zone.js and zone.js/testing.         Run ng update @angular/material@16.         supports TypeScript version 4.9.3 or later.         supports node.js versions: v16 and v18.   2. pipes y not directives          Purpose Misalignment:          Pipes are specifically designed to transform data in templates (e.g., converting dates, formatting numbers, filtering arrays).         Directives modify DOM behavior or structure, which is not suitable for inline data transformation.         Complexity:          Using a directive for simple data transformation (like formatting a date) would require DOM manipulation, which is cumbersome and less efficient than a pipe.         Directives and pipes serve different purposes in Angular. Pipes are specialized for data transformation in templates, while directives are meant to modify or control DOM elements' behavior. They are not interchangeable in most scenarios due to their differing design philosophies and applications.   3. promise methods              1. Promise.resolve()             Returns a promise that resolves with the given value.  <pre><code>Copy code\nPromise.resolve(\"Resolved value\").then((value) =&gt; console.log(value));\n// Output: Resolved value\n</code></pre> 2. Promise.reject() Returns a promise that rejects with the given reason.  <pre><code>Copy code\nPromise.reject(\"Rejected value\").catch((reason) =&gt; console.error(reason));\n// Output: Rejected value\n</code></pre>              3. Promise.all()             Waits for all promises in an array to resolve. If any promise is rejected, it immediately rejects with that reason.  <pre><code>Copy code\nconst p1 = Promise.resolve(10);\nconst p2 = Promise.resolve(20);\nconst p3 = Promise.reject(\"Error\");\n\nPromise.all([p1, p2, p3])\n.then((results) =&gt; console.log(results))\n.catch((error) =&gt; console.error(error));\n// Output: Error\n</code></pre> <pre><code>import { Observable } from 'rxjs';\n\n// Create an Observable\nconst observable = new Observable((subscriber) =&gt; {\n  subscriber.next('Hello');\n  subscriber.next('RxJS');\n  subscriber.complete();\n});\n\n// Create an Observer\nconst observer = {\n  next: (value: string) =&gt; console.log('Next:', value),\n  error: (err: any) =&gt; console.error('Error:', err),\n  complete: () =&gt; console.log('Completed!'),\n};\n\n// Subscribe to the Observable\nobservable.subscribe(observer);\n</code></pre> 4. event bubbling &amp; event capturing    When an event occurs on an element, it goes through the following phases:          Capturing Phase (Event Capturing):          The event starts at the topmost ancestor (e.g., document) and works its way down to the target element.         Target Phase:          The event reaches the target element, where the event handler on the target can execute.         Bubbling Phase (Event Bubbling):          The event propagates back up from the target element to the topmost ancestor.          Event Bubbling In event bubbling, the event propagates upward from the target element to its ancestors.   <pre><code>    &lt;div id=\"parent\" style=\"padding: 20px; background-color: lightblue;\"&gt;\nParent\n&lt;div id=\"child\" style=\"padding: 20px; background-color: lightgreen;\"&gt;\n    Child\n&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\nconst parent = document.getElementById(\"parent\");\nconst child = document.getElementById(\"child\");\n\nparent.addEventListener(\"click\", () =&gt; {\n    console.log(\"Parent clicked (Bubbling phase)\");\n});\n\nchild.addEventListener(\"click\", () =&gt; {\n    console.log(\"Child clicked\");\n});\n&lt;/script&gt;\n</code></pre>                              Event Capturing                 In event capturing, the event propagates downward from the topmost ancestor to the target element.                  Example of Event Capturing                 To use capturing, pass true as the third argument to addEventListener.             Parent clicked (Capturing phase)             Child clicked             Stopping Propagation             You can stop an event from propagating further by using event.stopPropagation().           Summary         Bubbling: Events propagate from the target element upward.         Capturing: Events propagate from the topmost ancestor downward.         Use stopPropagation() to stop further propagation.         Methods can be utilized inside event handlers to enhance functionality.         Event delegation optimizes event handling by attaching listeners to parent elements.  5. serve side events             Server-Sent Events (SSE) in JavaScript             Server-Sent Events (SSE) is a standard for pushing updates from a server to a web browser over a single HTTP connection. Unlike WebSockets, which allow two-way communication, SSE provides a unidirectional channel (server to client).              How SSE Works             The server sends data to the client over an HTTP connection.             The client listens to the server using an EventSource object.             Data is streamed as text/event-stream, which is continuously updated by the server.   6. flatmap    The map and flatMap methods are used to manipulate and transform arrays in JavaScript. They are part of the Array.prototype.          1. map()         The map method creates a new array by applying a function to each element of the original array.         . flatMap()         The flatMap method maps each element using a mapping function, then flattens the result into a new array. It's a combination of map() followed by flat() with a depth of 1.  <pre><code>    const arr = [1, 2, 3];\nconst result = arr.flatMap(x =&gt; [x, x * 2]);\nconsole.log(result);\n// Output: [1, 2, 2, 4, 3, 6]\n</code></pre>         map: For simple transformations.         flatMap: For transformations requiring flattening by one level. It simplifies your code and improves readability and performance when dealing with nested structures.   8. merge and forkjoin and merge map diff    In Angular's RxJS, merge, forkJoin, and mergeMap are commonly used operators for working with observables. Below is a detailed explanation of their differences and use cases.                  1. merge                 Combines multiple observables into one, emitting values from all observables as they occur.                 It subscribes to all observables simultaneously and merges their outputs into a single observable.                 Syntax  <pre><code>    Copy code\n    merge(observable1, observable2, ...).subscribe(observer);\n</code></pre>                 Key Points                 Emits values immediately as they are emitted by the source observables.                 Useful for concurrent streams where order does not matter.                 Example  <pre><code>    Copy code\n    import { merge, of } from 'rxjs';\n    import { delay } from 'rxjs/operators';\n\n    const obs1 = of('A').pipe(delay(1000));\n    const obs2 = of('B').pipe(delay(500));\n\n    merge(obs1, obs2).subscribe(value =&gt; console.log(value));\n    // Output: B, A (based on their delays);\n</code></pre>                  2. forkJoin                 Combines multiple observables into one but waits for all observables to complete before emitting a single array of their last emitted values.                 Best for scenarios where you need all results together after all observables complete.                 Syntax                 typescript                 Copy code                 forkJoin([observable1, observable2, ...]).subscribe(observer);                 Key Points                 Emits once when all source observables complete.                 Ideal for executing parallel tasks where results are interdependent.                 Example  <pre><code>Copy code\nimport { forkJoin, of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nconst obs1 = of('A').pipe(delay(1000));\nconst obs2 = of('B').pipe(delay(500));\n\nforkJoin([obs1, obs2]).subscribe(value =&gt; console.log(value));\n// Output: ['A', 'B'] (after all observables complete)\n</code></pre>                  3. mergeMap                 Projects each value from the source observable into an inner observable, then flattens the results into a single observable.                 Subscribes to multiple inner observables concurrently and merges their outputs.                 Syntax <pre><code>Copy code\nsource.pipe(mergeMap(value =&gt; innerObservable)).subscribe(observer);\nKey Points\nUseful when you need to map each emitted value to another observable and merge the results.\nInner observables emit values as soon as they are available.\nExample\ntypescript\nCopy code\nimport { of } from 'rxjs';\nimport { mergeMap, delay } from 'rxjs/operators';\n\nconst source = of('A', 'B');\nsource\n.pipe(\n    mergeMap(value =&gt;\n    of(`${value} processed`).pipe(delay(1000))\n    )\n)\n.subscribe(value =&gt; console.log(value));\n// Output: A processed, B processed (concurrently after ~1s)\n</code></pre> 9. Banking sector               Secure API Communication             Use CORS to restrict access to APIs from specific domains.             Validate and sanitize all API inputs on the server side.             Minimizing Payload             Use Angular CLI's build optimizer and tree-shaking to reduce bundle size.             Compress assets using Gzip or Brotli.  10. new feature in 17 like signals           ts 5.X         new control floe statements @if  11.flex is it fror responsiveness          How Flexbox Helps in Responsiveness         Dynamic Layouts:          Flexbox distributes space dynamically based on available dimensions, making layouts adjust naturally to screen size changes.         Alignment and Justification:          Use justify-content and align-items to control alignment and spacing of items in a flex container, helping maintain a consistent layout across devices.         Reordering and Wrapping:          The flex-wrap property enables items to wrap to the next row or column when there's insufficient space, preventing content overflow.         order allows reordering of elements for specific screen sizes.         Flexibility in Item Sizing:          The flex-grow, flex-shrink, and flex-basis properties provide control over how items resize relative to their container and siblings.  <pre><code>    &lt;div class=\"container\"&gt;\n    &lt;div class=\"item\"&gt;Item 1&lt;/div&gt;\n    &lt;div class=\"item\"&gt;Item 2&lt;/div&gt;\n    &lt;div class=\"item\"&gt;Item 3&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;style&gt;\n    .container {\n        display: flex;\n        justify-content: space-between;\n        gap: 10px;\n    }\n\n    .item {\n        background-color: lightblue;\n        padding: 20px;\n        flex-grow: 1;\n    }\n\n    @media (max-width: 600px) {\n        .container {\n        flex-direction: column; /* Stack items vertically on smaller screens */\n        }\n    }\n    &lt;/style&gt;\n</code></pre>  12. cherry pick in git     Test  <pre><code>12. cherry pick in git \n13. other methods as promise in js async something \n14. http and $ http diff\n</code></pre>"},{"location":"interview-exp/#tek-systems","title":"Tek Systems","text":"1. PWA Apps   Test      2. SSR    Test  3. Rxjs   Test   4. NgRx   Test  5. css framework sass   Test  6. typescript differences type of, type inference   Test"},{"location":"template/","title":"Header","text":""},{"location":"template/#title","title":"Title","text":""},{"location":"template/#anchor","title":"Anchor","text":""},{"location":"template/#table","title":"table","text":""},{"location":"template/#accordion","title":"accordion","text":"6. typescript differences type of, type inference   Test"},{"location":"template/#code-template","title":"code template","text":"<p>For note card</p>"},{"location":"template/#_1","title":"Header","text":"<ul> <li> <p>Scenario: </p> </li> <li> <p>Use Case:  .</p> </li> </ul>"},{"location":"angular/core-concepts/","title":"Core","text":""},{"location":"angular/core-concepts/#about-angular","title":"About angular","text":"<p>Note</p> <p>Angular Application Workflow from <code>index.html</code></p> <ol> <li><code>index.html</code> - The Entry Point </li> <li>The <code>index.html</code> file is the single HTML file that serves as the entry point for the Angular application.  </li> <li> <p>It typically contains a minimal structure with the following key elements:      <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;AngularApp&lt;/title&gt;\n  &lt;base href=\"/\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n  &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;app-root&gt;&lt;/app-root&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> </li> <li> <p>Explanation:</p> <ul> <li><code>&lt;base href=\"/\"&gt;</code>: Ensures the application uses relative paths correctly for routing.</li> <li><code>&lt;app-root&gt;</code>: This is the root component\u2019s selector, where the Angular application is rendered.</li> </ul> </li> <li> <p>Bootstrapping the Application </p> </li> <li>Angular starts by bootstrapping the application using the <code>main.ts</code> file.</li> <li> <p>The bootstrapping process:</p> <ul> <li>Loads <code>AppModule</code> (the root module).</li> <li>Instantiates the root component (<code>AppComponent</code>).</li> <li>Replaces the <code>&lt;app-root&gt;</code> tag in <code>index.html</code> with the rendered template of <code>AppComponent</code>.</li> </ul> </li> <li> <p><code>main.ts</code> - Starting the App </p> </li> <li>The <code>main.ts</code> file is the starting point of the Angular application.</li> <li> <p>It calls the <code>platformBrowserDynamic().bootstrapModule(AppModule)</code> method to start the app.</p> </li> <li> <p><code>AppModule</code> - Root Module </p> </li> <li><code>AppModule</code> is the root module that declares and bootstraps the root component (<code>AppComponent</code>).</li> <li> <p>It imports necessary Angular modules (like <code>BrowserModule</code>, <code>AppRoutingModule</code>) and registers services.</p> </li> <li> <p><code>AppComponent</code> - Root Component </p> </li> <li>The <code>AppComponent</code> is the first component loaded and displayed in the browser.</li> <li> <p>It defines the root template, which may contain other components, directives, and services.</p> </li> <li> <p>Component Rendering </p> </li> <li>Angular replaces the <code>&lt;app-root&gt;</code> element in <code>index.html</code> with the rendered content of <code>AppComponent</code>.</li> <li> <p>Any child components declared in the template of <code>AppComponent</code> are also rendered.</p> </li> <li> <p>Data Binding and Directives </p> </li> <li> <p>Angular synchronizes data between the component class and the view using:</p> <ul> <li>Interpolation (<code>{{ }}</code>) for displaying data.</li> <li>Property Binding (<code>[property]</code>) to bind data to DOM properties.</li> <li>Event Binding (<code>(event)</code>) to handle user interactions.</li> </ul> </li> <li> <p>Routing </p> </li> <li>If the app has multiple pages, the Angular Router handles navigation between components.</li> <li> <p>The <code>AppRoutingModule</code> defines the routes and dynamically loads the components based on the URL.</p> </li> <li> <p>Reactive Programming with RxJS </p> </li> <li> <p>Angular uses RxJS for handling asynchronous events like HTTP requests or user interactions.</p> </li> <li> <p>Change Detection </p> <ul> <li>Angular\u2019s change detection mechanism updates the UI whenever the component state changes.</li> </ul> </li> <li> <p>Compilation and Rendering </p> <ul> <li>Angular compiles templates and components into JavaScript code:</li> <li>Just-In-Time (JIT): Compiles during runtime (development mode).</li> <li>Ahead-of-Time (AOT): Compiles during build time (production mode).</li> </ul> </li> </ol> <p>// diff btn  v1 &amp; v2+</p>"},{"location":"angular/core-concepts/#what-is-angular","title":"What is Angular?","text":"<p>Angular is a TypeScript-based open-source web application framework developed by Google. It is used to build single-page applications (SPA) with features like data binding, dependency injection, and a component-based architecture. - Component-Based Architecture: UI is built using reusable components. - Two-Way Data Binding: Synchronizes data between model and view. - Dependency Injection: Provides services to components or other services. - Directives: Extend HTML with custom attributes and behavior. - RxJS: Handles asynchronous data streams. - Routing: Provides navigation between views or components.</p>"},{"location":"angular/core-concepts/#difference-between-angular-and-angularjs","title":"Difference Between Angular and AngularJS","text":"Feature Angular AngularJS Language TypeScript JavaScript Architecture Component-based Controller-based (MVC) Data Binding Two-way with <code>[(ngModel)]</code> Two-way with <code>ng-model</code> Mobile Support Native mobile support (Ionic) No direct mobile support Performance Faster Slower (due to digest cycle)"},{"location":"angular/core-concepts/#js-and-ts","title":"JS and TS","text":"<p>Key Differences Between JS and TS</p> Feature JavaScript (JS) TypeScript (TS) Definition A dynamic, interpreted programming language used primarily for building web applications. A superset of JavaScript that adds static typing and other features for better development. Typing Dynamically typed, meaning variables can change types during runtime. Statically typed, meaning variable types are defined during compile time and cannot change. Compilation Interpreted directly by the browser or Node.js. Compiled to JavaScript before execution, ensuring type-checking at compile time. Type Annotations No type annotations, the type of a variable is inferred at runtime. Supports type annotations (e.g., <code>let x: number = 10;</code>). Error Handling Errors are typically caught at runtime. Errors can be caught at compile time due to static type checking. Features Basic features such as functions, objects, and arrays. Includes advanced features like interfaces, enums, generics, and type aliases. Support for Classes JavaScript ES6 introduced classes but with no strong typing or interface support. TypeScript extends JavaScript classes with strict type checks and support for interfaces. Tooling and IDE Support Limited tooling for error detection and code completion. Offers better tooling with IDEs providing autocompletion, refactoring, and static type checking. Compatibility Supported natively in all modern browsers and Node.js environments. TypeScript code needs to be transpiled into JavaScript to run in browsers or Node.js. Development Speed Faster to start and more flexible, but can lead to runtime errors. Slower to start due to strict type definitions but offers better maintainability and fewer runtime errors."},{"location":"angular/core-concepts/#polyfills-transpiler","title":"polyfills &amp; transpiler","text":"<p>Note</p> <p>Polyfills Polyfills are the code that makes the application compatible with different browsers. - Purpose: ES6 code is not compatible with some older browsers like Internet Explorer (IE) or certain versions of Firefox. - Solution: Polyfills provide the necessary environment setup to enable the application to run in these browsers.</p> <p>Transpiler - Definition: Transpiling is the process of transforming source code from one programming language to another. - In Angular: The TypeScript code used for development is transpiled to JavaScript, which can be executed in the browser.</p> <p>Webpack - Definition: Webpack is a module bundler that packages application source code into convenient chunks. - Purpose: It helps load the code from the server to the browser efficiently, optimizing performance and resource management.</p>"},{"location":"angular/core-concepts/#common-angular-cli-commands","title":"Common Angular CLI Commands","text":"Command Description <code>npm install -g @angular/cli</code> Installs Angular CLI globally on your machine. <code>npm install bootstrap</code> Installs Bootstrap for UI styling. <code>ng serve</code> Serves the application locally on a development server. <code>ng g c componentName</code> Generates a new component with the specified name. <code>ng g d directiveName</code> Generates a new directive with the specified name. <code>ng g s serviceName</code> Generates a new service with the specified name. <code>ng g m moduleName</code> Generates a new module with the specified name."},{"location":"angular/core-concepts/#angular-compilation-and-rendering","title":"Angular Compilation and Rendering","text":"<p>How Angular Application Works with JIT and AOT Compilation</p> <p>Angular applications consist of components and templates that the browser does not understand directly. Therefore, they need to be compiled before running inside the browser.</p> <p>Just-In-Time (JIT) Compilation - In JIT Compilation, the application is compiled inside the browser during runtime. - Workflow:   - Development \u2192 Production \u2192 App downloaded in Browser \u2192 Angular compiles templates to JavaScript (JS). - Suitable for development environments as it allows quick testing and debugging.</p> <p>Ivy: Angular's Compilation and Rendering Engine - Ivy is the code name for Angular's compilation and rendering pipeline. - Starting from Angular 9, applications are Ivy-compiled by default. - Ivy improves the performance and reduces the bundle size of Angular applications.</p> <p>Ahead-of-Time (AOT) Compilation - In AOT Compilation, the application is compiled during build time before being served to the browser. - Workflow:   - Development \u2192 Angular compiles templates to JavaScript during build time \u2192 Production. - Suitable for production environments as it provides faster rendering and better performance.</p> <p>Benefits of AOT Compilation - The application is compiled before running inside the browser, allowing the browser to:   - Load executable code and render the app immediately.   - Avoid the need for extra HTML files since the HTML and templates are embedded into the JavaScript files. - This approach provides better security by minimizing the risk of malicious template injections.</p>"},{"location":"angular/core-concepts/#view-encapsulation","title":"View Encapsulation","text":"<p>Note</p> <ul> <li>encapasulation: viewEncapsulation.Emulated :default behaviour where the styles apply only to its own</li> <li>encapasulation: viewEncapsulation.none : will apply globally</li> <li>encapasulation: viewEncapsulation.ShadowDom: Angular uses the browser's built-in Shadow DOM API to enclose the    component's view inside a ShadowRoot, used as the component's host element, and apply the provided styles in an isolated manner. Not all browsers support it, which is why the ViewEncapsulation.Emulated is the recommended and default mode. </li> </ul>"},{"location":"angular/core-concepts/#angular-app-optimization","title":"Angular app Optimization","text":"<p>Note</p> <ul> <li>Use Lazy Loading for feature modules.</li> <li>Use Ahead-of-Time (AOT) Compilation.</li> <li>Use TrackBy in <code>*ngFor</code> for efficient DOM updates.</li> <li>Use Pure Pipes instead of methods in templates.</li> <li>Unsubscribe from Observables to prevent memory leaks.</li> <li>Use OnPush Change Detection Strategy for immutable data.   </li> </ul>"},{"location":"angular/core-concepts/#lifecycle-hooks","title":"Lifecycle hooks","text":"Lifecycle Hook Description Method Signature Real-World Scenario ngOnChanges Called when an input property changes. <code>ngOnChanges(changes: SimpleChanges)</code> Used to react to changes in input properties, such as updating a child component when a parent component's data changes. ngOnInit Called once after the first <code>ngOnChanges</code>. Used to initialize component data. <code>ngOnInit()</code> Ideal for fetching data from APIs when a component loads for the first time. Example: Load user data when a profile page is opened. ngDoCheck Called during every change detection run, allowing custom change detection logic. <code>ngDoCheck()</code> Useful for manually detecting changes in deeply nested or immutable objects. Example: Track changes in a complex form object. ngAfterContentInit Called once after content projection (<code>&lt;ng-content&gt;</code>) has been initialized. <code>ngAfterContentInit()</code> Used to perform actions after projected content is fully initialized. Example: Logging or manipulating projected content in a modal component. ngAfterContentChecked Called after every change detection run for projected content. <code>ngAfterContentChecked()</code> Ensures the projected content is up to date. Example: Validate form content projected from a parent component. ngAfterViewInit Called once after the component's view and child views have been initialized. <code>ngAfterViewInit()</code> Useful for DOM manipulation or initializing third-party libraries. Example: Initializing a chart library after the DOM is ready. ngAfterViewChecked Called after every change detection run for the component's view and child views. <code>ngAfterViewChecked()</code> Used to check the component\u2019s view for changes. Example: Updating UI elements like tooltips after every change detection cycle. ngOnDestroy Called once before the component is destroyed. Used for cleanup logic. <code>ngOnDestroy()</code> Ideal for unsubscribing from observables or detaching event handlers to prevent memory leaks. Example: Unsubscribe from a WebSocket connection when leaving a chat page."},{"location":"angular/core-concepts/#change-detection-in-angular","title":"Change Detection in Angular","text":"<p>What is Change Detection in Angular?</p> <p>Change Detection is the mechanism in Angular that keeps the data model and the view (UI) in sync. It ensures that changes in the application\u2019s state are automatically reflected in the DOM (Document Object Model), and vice versa.</p> <p>Key Concepts of Change Detection</p> Concept Description Purpose Ensures that changes in the component\u2019s data model are reflected in the view. How it Works Angular monitors component state and compares it to the previous state. If a change is detected, the DOM is updated. Triggering Mechanisms Change detection is triggered by events such as user input, HTTP responses, or timer events. Zones Angular uses Zones to intercept asynchronous operations like <code>setTimeout</code>, promises, and event listeners to trigger change detection automatically. Change Detection Strategies Angular provides two strategies: Default and OnPush. <p>Change Detection Strategies</p> Strategy Description Use Case Default Checks the entire component tree for changes. Suitable for applications with frequent or unpredictable data changes. OnPush Checks only when input properties of the component change or when an event is triggered. Suitable for performance optimization in large applications where data changes are predictable. <p>Real-World Scenario for Change Detection</p> <ul> <li> <p>E-Commerce Application:   In a shopping cart component, when a user adds or removes items, the change detection mechanism updates the total price and item list in real-time without needing a page refresh.</p> </li> <li> <p>Chat Application:   Incoming messages from a WebSocket connection are displayed immediately in the chat window using change detection to update the UI.</p> </li> </ul> <ol> <li> <p>What is Change Detection in Angular?    It is the process by which Angular updates the DOM whenever there is a change in the component's state.</p> </li> <li> <p>How does Angular detect changes?    Angular uses a digest cycle where it compares the current state of the component with its previous state to detect changes.</p> </li> <li> <p>What is the difference between Default and OnPush strategies? </p> </li> <li>Default: Checks the entire component tree.  </li> <li> <p>OnPush: Checks only when the input properties change or an event occurs, improving performance.</p> </li> <li> <p>When would you use OnPush strategy?    Use OnPush for components with immutable data or when optimizing performance in applications with large data sets.</p> <ul> <li>What is NgZone? NgZone helps Angular manage change detection by running tasks outside of Angular\u2019s zone and triggering change detection when necessary.</li> </ul> </li> </ol>"},{"location":"angular/core-concepts/#modules-components-services-view-encapsu-inehitance-compo","title":"Modules, components, services  (view-encapsu, inehitance compo)","text":"<pre><code># Components, Modules, and Services in Angular\n</code></pre> <p>Overview of Components, Modules, and Services in Angular</p> <p>Angular applications are built using components, organized into modules, and powered by services for business logic and data sharing.</p>"},{"location":"angular/core-concepts/#components","title":"Components","text":"Feature Description Definition A component controls a section of the user interface (UI). It defines the view and logic for that part of the screen. Structure A component consists of three main parts: - Template (HTML): Defines the UI layout and appearance. - Class (TypeScript): Contains the logic and data-binding for the template. - Styles (CSS/SCSS): Defines the component-specific styling. Selector The custom HTML tag that represents the component in a template (e.g., <code>&lt;app-header&gt;</code>). Real-World Scenario A HeaderComponent that contains the navigation menu and logo for a web application."},{"location":"angular/core-concepts/#modules","title":"Modules","text":"Feature Description Definition A module is a container for a cohesive block of functionality within an Angular app. Root Module Every Angular app has at least one root module (<code>AppModule</code>), which bootstraps the application. Feature Modules Used to organize and encapsulate related components, services, and pipes (e.g., <code>UserModule</code>, <code>ProductModule</code>). NgModule Decorator Declares the components, directives, and pipes that belong to the module and imports other required modules. Real-World Scenario A UserModule that contains all user-related components (e.g., user profile, user settings)."},{"location":"angular/core-concepts/#services","title":"Services","text":"Feature Description Definition A service is a class that contains business logic, reusable functions, and data retrieval methods. Dependency Injection Services are injected into components or other services using Angular\u2019s Dependency Injection (DI) system. Scope Services can be application-wide (provided in <code>AppModule</code>) or module-specific. Real-World Scenario A ProductService that fetches product data from an API and provides it to various components (e.g., ProductList, ProductDetails)."},{"location":"angular/core-concepts/#summary","title":"Summary","text":"<ul> <li>Components: Define the UI and logic for a specific part of the application.</li> <li>Modules: Organize the application into cohesive blocks of functionality.</li> <li>Services: Handle business logic and data sharing, and can be injected into components or other services.</li> </ul>"},{"location":"angular/core-concepts/#data-binding","title":"Data Binding","text":"<p>Overview of Data Binding in Angular</p> <p>Data Binding in Angular is the mechanism that allows communication between the component's TypeScript code and the template (HTML). It keeps the data model and the view in sync, enabling dynamic and interactive user interfaces.</p>"},{"location":"angular/core-concepts/#types-of-data-binding-in-angular","title":"Types of Data Binding in Angular","text":"Type Syntax Description Real-World Scenario Interpolation <code>{{ expression }}</code> Displays data from the component class in the template by evaluating an expression. Displaying a user's name dynamically on the UI: <code>{{ user.name }}</code>. Property Binding <code>[property]=\"expression\"</code> Binds a component property to an HTML element property. Dynamically setting the <code>src</code> attribute of an image: <code>&lt;img [src]=\"imageUrl\"&gt;</code>. Event Binding <code>(event)=\"handler\"</code> Binds an HTML event to a method in the component class. Handling button clicks: <code>&lt;button (click)=\"onSubmit()\"&gt;Submit&lt;/button&gt;</code>. Two-Way Binding <code>[(ngModel)]=\"property\"</code> Combines property binding and event binding to bind data both ways between the view and the model. Synchronizing a form input with a variable: <code>&lt;input [(ngModel)]=\"username\"&gt;</code>."},{"location":"angular/core-concepts/#detailed-explanation-of-data-binding-types","title":"Detailed Explanation of Data Binding Types","text":""},{"location":"angular/core-concepts/#1-interpolation","title":"1. Interpolation","text":"<ul> <li>Definition: Used to display component data in the template.  </li> <li>Syntax: <code>{{ expression }}</code> </li> <li>Example: Displaying a dynamic greeting message like <code>Hello, {{ user.name }}!</code>.  </li> <li>Use Case: Display static or dynamic data in the UI.</li> </ul>"},{"location":"angular/core-concepts/#2-property-binding","title":"2. Property Binding","text":"<ul> <li>Definition: Binds a property in the component to a DOM property in the template.  </li> <li>Syntax: <code>[property]=\"expression\"</code> </li> <li>Example: <code>&lt;input [value]=\"user.name\"&gt;</code> binds the input field's value to <code>user.name</code>.  </li> <li>Use Case: Dynamically change element attributes, such as <code>src</code>, <code>disabled</code>, <code>hidden</code>, or <code>class</code>.</li> </ul>"},{"location":"angular/core-concepts/#3-event-binding","title":"3. Event Binding","text":"<ul> <li>Definition: Binds an event emitted by a DOM element to a method in the component.  </li> <li>Syntax: <code>(event)=\"handler\"</code> </li> <li>Example: <code>&lt;button (click)=\"submitForm()\"&gt;Submit&lt;/button&gt;</code> calls the <code>submitForm()</code> method when the button is clicked.  </li> <li>Use Case: Handle user interactions like clicks, keypresses, or form submissions.</li> </ul>"},{"location":"angular/core-concepts/#4-two-way-data-binding","title":"4. Two-Way Data Binding","text":"<ul> <li>Definition: Combines property binding and event binding to create a synchronized connection between the view and the model.  </li> <li>Syntax: <code>[(ngModel)]=\"property\"</code> </li> <li>Example: <code>&lt;input [(ngModel)]=\"user.name\"&gt;</code> updates <code>user.name</code> whenever the input value changes and vice versa.  </li> <li>Use Case: Create dynamic forms where input values need to be reflected in real-time in the model.</li> </ul>"},{"location":"angular/core-concepts/#summary_1","title":"Summary","text":"<ul> <li>Interpolation: For displaying dynamic data in the template.</li> <li>Property Binding: For dynamically binding DOM properties to component properties.</li> <li>Event Binding: For handling user interactions.</li> <li>Two-Way Binding: For synchronizing data between the component and the view in real-time.</li> </ul> <p>Best Practice</p> <p>Use One-Way Data Binding (Interpolation, Property Binding, Event Binding) when possible for better performance, and reserve Two-Way Binding for forms and inputs where real-time synchronization is required.</p>"},{"location":"angular/core-concepts/#directives","title":"Directives","text":"<p>Overview of Directives in Angular</p> <p>Directives are special instructions in Angular that enhance the functionality of HTML elements. They help manipulate the DOM, control behavior, and apply dynamic styles or logic.</p> <p>Types of Directives</p> Type Description Syntax Example Real-World Scenario Component Directive A directive with a template, logic, and styles that defines a UI block. <code>&lt;app-header&gt;&lt;/app-header&gt;</code> A HeaderComponent used for displaying a site\u2019s header across pages. Structural Directive Changes the structure of the DOM by adding or removing elements. <code>*ngIf</code>, <code>*ngFor</code>, <code>*ngSwitch</code> Display a list of items dynamically using <code>*ngFor</code>. Attribute Directive Changes the appearance or behavior of an existing element without altering its structure. <code>[ngClass]</code>, <code>[ngStyle]</code> Highlight an element conditionally using <code>[ngClass]=\"{'active': isActive}\"</code>. <p>Built-in Directives</p> Directive Type Description Real-World Scenario <code>*ngIf</code> Structural Conditionally includes or excludes a template based on a boolean expression. Display a \"Loading...\" message while waiting for data to load. <code>*ngFor</code> Structural Repeats a template for each item in a collection. Render a list of products in an e-commerce application. <code>[ngClass]</code> Attribute Dynamically adds or removes CSS classes. Highlight a selected menu item based on user interaction. <code>[ngStyle]</code> Attribute Dynamically applies inline styles. Change the color of a warning message based on its severity level."},{"location":"angular/core-concepts/#custom-directives","title":"Custom Directives","text":"<p>What is a Custom Directive? A Custom Directive is a user-defined directive that extends the functionality of Angular\u2019s built-in directives or adds new behaviors to the DOM.</p> <p>Steps to Create a Custom Directive 1. Generate a directive using Angular CLI: <code>ng generate directive directiveName</code> 2. Define the directive logic inside the TypeScript class. 3. Use the directive in a template by applying it to an element.</p> <p>Example of a Custom Directive</p> Feature Description Real-World Scenario HighlightDirective A custom directive that changes the background color of an element when the user hovers over it. Scenario: Highlighting table rows in a data grid when the user hovers over them. FocusDirective A custom directive that automatically focuses an input field when the page loads. Scenario: Automatically focusing the username field on a login form."},{"location":"angular/core-concepts/#example-highlightdirective","title":"Example: HighlightDirective","text":"Feature Description Directive Logic Listens for mouse events (<code>mouseenter</code>, <code>mouseleave</code>) and changes the background color accordingly. Usage <code>&lt;p appHighlight&gt;Hover over this text to see the highlight effect.&lt;/p&gt;</code> <p>Summary</p> <ul> <li>Component Directives define UI blocks with a template, logic, and styles.</li> <li>Structural Directives manipulate the DOM structure by adding or removing elements (<code>*ngIf</code>, <code>*ngFor</code>).</li> <li>Attribute Directives modify the behavior or appearance of an element (<code>[ngClass]</code>, <code>[ngStyle]</code>).</li> <li>Custom Directives add new behavior to elements, enhancing user interaction or automating tasks.</li> </ul> <p>Best Practice</p> <p>Use Custom Directives to encapsulate reusable behavior that can be applied across multiple components, ensuring a clean and modular codebase.</p> <p>Passing Data to Directives in Angular</p> <p>Overview</p> <p>In Angular, you can pass data to a custom directive using input properties. This allows the directive to receive dynamic data from the parent component and perform actions based on that data.</p> <p>Steps to Pass Data to a Custom Directive</p> <ol> <li>Create a Custom Directive.</li> <li>Use the <code>@Input</code> decorator to define input properties in the directive.</li> <li>Pass data from the parent component through the directive\u2019s selector.</li> </ol> <p>Example Scenario: Passing Data to a Custom Highlight Directive</p> <p>Use Case We want to create a HighlightDirective that changes the background color of a paragraph based on the color value passed from the parent component.</p> <p>Step-by-Step Explanation</p> Step Description Example Syntax 1. Define Input Property Use the <code>@Input</code> decorator in the directive to declare a property that will accept data. <code>@Input() appHighlightColor: string = '';</code> 2. Apply Directive in Template Use the directive in a template and pass the color value as an attribute. <code>&lt;p [appHighlightColor]=\"'yellow'\"&gt;Highlighted Text&lt;/p&gt;</code> 3. Use Input Value in Directive Logic Use the input property to set the background color or apply logic. <code>this.el.nativeElement.style.backgroundColor = this.appHighlightColor;</code> <p>Code Example</p> <p>Directive Class (HighlightDirective)</p> <pre><code>import { Directive, ElementRef, Input, OnInit } from '@angular/core';\n\n@Directive({\n  selector: '[appHighlightColor]'\n})\nexport class HighlightDirective implements OnInit {\n  @Input() appHighlightColor: string = '';\n\n  constructor(private el: ElementRef) {}\n\n  ngOnInit() {\n    this.el.nativeElement.style.backgroundColor = this.appHighlightColor;\n  }\n}\n\nexport class AppComponent {\n  dynamicColor: string = 'lightgreen';\n}\nSummary\nUse the @Input decorator to pass data into a custom directive.\nBind the directive property to a dynamic value or a static value in the template.\nThis approach allows directives to be flexible and reusable across different components.\n## ng-template, ng-content\n</code></pre>"},{"location":"angular/core-concepts/#angular-singleton-service","title":"Angular Singleton Service","text":"<p>A Singleton Service in Angular is a service that exists as a single instance throughout the lifecycle of an application. This ensures that the same instance of the service is shared across the entire app, providing a centralized way to manage data, logic, or shared state.</p> <p>Key Features of Singleton Services</p> <ol> <li>Single Instance: Only one instance of the service is created and shared across all components.</li> <li>State Sharing: Useful for sharing data or state between different parts of the application.</li> <li>Efficient Resource Usage: Reduces overhead by avoiding the creation of multiple instances.</li> </ol> <p>Creating a Singleton Service</p> <p>To make a service a singleton, it should be provided at the root level.</p> <p>Example</p> <p>Step 1: Generate a Service Use the Angular CLI to generate a service: ```bash ng generate service my-service</p>"},{"location":"angular/forms/","title":"Angular Forms - Interview Questions and Answers","text":"<p>Overview</p> <p>Angular provides two types of forms for handling user input: Template-driven Forms and Reactive Forms. Both approaches are used to build forms but differ in how they manage form control and validation. Understanding when and how to use them is crucial for Angular development.</p>"},{"location":"angular/forms/#types-of-forms-in-angular","title":"Types of Forms in Angular","text":"Type of Form Description Usage Scenario Template-driven Forms Forms are defined in the template using <code>ngModel</code>. Forms are mostly managed by Angular. Simpler forms or when forms don\u2019t require complex logic (e.g., login forms). Reactive Forms Forms are defined in the component using <code>FormGroup</code> and <code>FormControl</code>. Provides more control. Complex forms with dynamic validations or extensive logic (e.g., dynamic forms)."},{"location":"angular/forms/#template-driven-forms","title":"Template-Driven Forms","text":""},{"location":"angular/forms/#what-are-template-driven-forms-in-angular","title":"What are Template-Driven Forms in Angular?","text":"<p>Answer: Template-driven forms are forms that are defined in the template using the <code>ngModel</code> directive. Angular automatically tracks form input and validation state. These forms are easier to set up and require less code, making them ideal for simpler scenarios.</p>"},{"location":"angular/forms/#how-to-create-template-driven-forms","title":"How to Create Template-Driven Forms?","text":"<pre><code>&lt;form #form=\"ngForm\" (ngSubmit)=\"onSubmit(form)\"&gt;\n  &lt;input type=\"text\" name=\"username\" ngModel required /&gt;\n  &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"angular/forms/#reactive-forms","title":"Reactive Forms","text":""},{"location":"angular/forms/#what-are-reactive-forms-in-angular","title":"What are Reactive Forms in Angular?","text":"<p>Answer</p> <p>Reactive forms are more structured and are defined entirely in the component class using <code>FormGroup</code>, <code>FormControl</code>, and <code>FormBuilder</code>. This approach provides more control over the form logic and validation, making it ideal for complex forms with dynamic validations or large forms.</p>"},{"location":"angular/forms/#how-to-create-reactive-forms","title":"How to Create Reactive Forms?","text":"<p>Example</p> <pre><code>import { Component } from '@angular/core';\nimport { FormGroup, FormBuilder, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-registration',\n  templateUrl: './registration.component.html',\n})\nexport class RegistrationComponent {\n  registrationForm: FormGroup;\n\n  constructor(private fb: FormBuilder) {\n    this.registrationForm = this.fb.group({\n      username: ['', Validators.required],\n      email: ['', [Validators.required, Validators.email]],\n    });\n  }\n\n  onSubmit() {\n    console.log(this.registrationForm.value);\n  }\n}\n</code></pre>"},{"location":"angular/forms/#common-interview-questions-on-forms-in-angular","title":"Common Interview Questions on Forms in Angular","text":""},{"location":"angular/forms/#1-what-is-the-difference-between-template-driven-and-reactive-forms","title":"1. What is the difference between Template-driven and Reactive Forms?","text":"Feature Template-driven Forms Reactive Forms Configuration Defined in the template using <code>ngModel</code>. Defined in the component using <code>FormGroup</code> and <code>FormControl</code>. Control Tracking Angular tracks form controls automatically. Manual tracking of form controls and validation. Validation Validation is done directly in the template. Validation is done in the component using validators. Complexity Simple and easy to use for small forms. More control and better for complex forms."},{"location":"angular/forms/#2-what-is-ngmodel-in-template-driven-forms","title":"2. What is ngModel in Template-driven forms?","text":"<p>Answer</p> <p><code>ngModel</code> is a directive used to bind form controls to component properties in template-driven forms. It creates a two-way data binding between the form input field and the model in the component, allowing automatic updates when either the view or model changes.</p> <p>Example: <pre><code>&lt;input [(ngModel)]=\"user.name\" name=\"name\" /&gt;\n</code></pre></p>"},{"location":"angular/forms/#3-what-is-formgroup-and-formcontrol-in-reactive-forms","title":"3. What is FormGroup and FormControl in Reactive Forms?","text":"<p>Answer</p> <ul> <li><code>FormGroup</code>: A collection of form controls that track the value and validation state of the form.</li> <li><code>FormControl</code>: A single unit of form input that tracks the value and validation state of an individual form element.</li> </ul> <p>Example: <pre><code>this.form = new FormGroup({\n  firstName: new FormControl('', Validators.required),\n  lastName: new FormControl('', Validators.required),\n});\n</code></pre></p>"},{"location":"angular/forms/#4-what-are-validators-in-angular-forms","title":"4. What are Validators in Angular Forms?","text":"<p>Answer</p> <p>Validators are used to define rules for form fields to ensure the data is valid. Angular provides built-in validators like <code>required</code>, <code>minlength</code>, <code>maxlength</code>, <code>pattern</code>, etc. You can also create custom validators for more complex validation logic.</p> <p>Example of built-in validators: <pre><code>import { Validators, FormControl } from '@angular/forms';\n\nconst name = new FormControl('', [Validators.required, Validators.minLength(3)]);\n</code></pre></p>"},{"location":"angular/forms/#5-how-to-handle-form-validation-in-angular","title":"5. How to Handle Form Validation in Angular?","text":"<p>Answer</p> <p>Validation in Angular is handled differently in template-driven and reactive forms.</p> <ul> <li>Template-driven Forms: Use directives like <code>required</code>, <code>minlength</code>, and <code>ngModel</code> for validation.</li> <li>Reactive Forms: Validators are applied directly in the component using the <code>Validators</code> class.</li> </ul> <p>Example in reactive forms:</p> <pre><code>this.form = this.fb.group({\n  username: ['', [Validators.required, Validators.minLength(5)]],\n  email: ['', [Validators.required, Validators.email]],\n});\n</code></pre>"},{"location":"angular/forms/#6-how-do-you-handle-form-submission-in-angular","title":"6. How Do You Handle Form Submission in Angular?","text":"<p>Answer</p> <p>For form submission, you can use the <code>(ngSubmit)</code> event in template-driven forms or the <code>onSubmit()</code> method in reactive forms.</p> <ul> <li>Template-driven form:</li> </ul> <pre><code>&lt;form #form=\"ngForm\" (ngSubmit)=\"onSubmit(form)\"&gt;\n  &lt;input name=\"username\" ngModel required /&gt;\n  &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <ul> <li>Reactive form:</li> </ul> <pre><code>onSubmit() {\n  if (this.registrationForm.valid) {\n    console.log(this.registrationForm.value);\n  }\n}\n</code></pre>"},{"location":"angular/forms/#real-world-scenarios-for-angular-forms","title":"Real-World Scenarios for Angular Forms","text":"Scenario Use Case Form Type Login Form A simple form with username and password fields. Template-driven form Registration Form A complex form with dynamic validation rules like confirming password and email validation. Reactive form Dynamic Forms A form with dynamic fields added/removed based on user selection. Reactive form Survey Form A form with multiple sections and conditional validation based on previous answers. Reactive form"},{"location":"angular/forms/#summary","title":"Summary","text":"<ul> <li>Template-driven Forms are simple to use and suitable for smaller forms.</li> <li>Reactive Forms provide more control, are more scalable, and are ideal for complex forms.</li> <li>FormGroup and FormControl are key components in reactive forms for grouping and managing form fields.</li> <li>Angular provides built-in validators and also supports custom validators for flexible form validation.</li> <li>ngModel provides two-way data binding in template-driven forms.</li> </ul> <p>Best Practice</p> <p>Use Reactive Forms for complex forms that require extensive validation or dynamic form fields. Use Template-driven Forms for simple, one-time forms where the validation is straightforward.</p>"},{"location":"angular/forms/#custom-validators-form-arrays-patchvalue-vs-setvalue-in-angular","title":"Custom Validators, Form Arrays, patchValue vs setValue in Angular","text":"<p>Overview</p> <p>In Angular, custom validators allow you to create your own validation logic, FormArrays provide a way to handle dynamic collections of form controls, and the <code>patchValue</code> and <code>setValue</code> methods allow you to update form values flexibly.</p>"},{"location":"angular/forms/#custom-validators-in-angular","title":"Custom Validators in Angular","text":""},{"location":"angular/forms/#what-are-custom-validators","title":"What Are Custom Validators?","text":"<p>Answer</p> <p>Custom validators are functions that allow you to define custom validation logic for form controls or form groups. You can create validators to check for specific conditions that are not covered by the built-in validators.</p>"},{"location":"angular/forms/#how-to-create-a-custom-validator","title":"How to Create a Custom Validator?","text":"<p>To create a custom validator, define a function that returns either <code>null</code> (valid) or an error object (invalid).</p> <p>Example: Email Domain Validator</p> <p>Scenario: A form field should only accept email addresses from a specific domain (e.g., <code>example.com</code>).</p> <ol> <li> <p>Create a Custom Validator Function:</p> <pre><code>import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\n\nexport function emailDomainValidator(domain: string): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null =&gt; {\n    const email = control.value;\n    if (email &amp;&amp; !email.endsWith(`@${domain}`)) {\n      return { invalidEmailDomain: { value: control.value } };\n    }\n    return null;\n  };\n}\n</code></pre> </li> <li> <p>Use the Custom Validator in a FormControl:</p> <pre><code>this.form = this.fb.group({\n  email: ['', [Validators.required, emailDomainValidator('example.com')]],\n});\n</code></pre> </li> </ol>"},{"location":"angular/forms/#form-arrays-in-angular","title":"Form Arrays in Angular","text":""},{"location":"angular/forms/#what-is-a-formarray","title":"What is a FormArray?","text":"<p>Answer</p> <p>A FormArray is a container for managing an array of form controls or form groups. It allows you to handle dynamic forms, such as a list of items, where each item can have its own set of form controls.</p>"},{"location":"angular/forms/#how-to-create-and-use-a-formarray","title":"How to Create and Use a FormArray?","text":"<ol> <li> <p>Define a FormArray:</p> <pre><code>import { FormArray, FormBuilder, FormGroup, Validators } from '@angular/forms';\n\nthis.form = this.fb.group({\n  skills: this.fb.array([\n    this.fb.control('', Validators.required)\n  ])\n});\n</code></pre> </li> <li> <p>Add Form Controls Dynamically to the FormArray:</p> <pre><code>get skills() {\n  return this.form.get('skills') as FormArray;\n}\n\naddSkill() {\n  this.skills.push(this.fb.control('', Validators.required));\n}\n</code></pre> </li> <li> <p>Loop Through FormArray in Template:</p> <pre><code>&lt;form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\"&gt;\n  &lt;div formArrayName=\"skills\"&gt;\n    &lt;div *ngFor=\"let skill of skills.controls; let i = index\"&gt;\n      &lt;input [formControlName]=\"i\" placeholder=\"Skill\" /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;button type=\"button\" (click)=\"addSkill()\"&gt;Add Skill&lt;/button&gt;\n  &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> </li> </ol>"},{"location":"angular/forms/#patchvalue-vs-setvalue-in-angular","title":"<code>patchValue</code> vs <code>setValue</code> in Angular","text":""},{"location":"angular/forms/#what-is-setvalue","title":"What is <code>setValue</code>?","text":"<p>Answer</p> <p><code>setValue</code> is used to update the values of a form group or form array with complete values. All form controls in the form group or array must have a value assigned.</p> <p>Example Using <code>setValue</code>:</p> <pre><code>this.form.setValue({\n  firstName: 'John',\n  lastName: 'Doe',\n  email: 'john.doe@example.com'\n});\nIn the above example, all fields must be present in the form, otherwise, an error will occur.\n</code></pre>"},{"location":"angular/forms/#what-is-patchvalue","title":"What is <code>patchValue</code>?","text":"<p>Answer</p> <p><code>patchValue</code> is similar to <code>setValue</code>, but it allows you to partially update the form values. It only updates the values for the specified controls, and it will ignore any controls that are not passed.</p> <p>Example Using <code>patchValue</code>:</p> <pre><code>this.form.patchValue({\n  firstName: 'John'\n});\n</code></pre> <p>In this example, only the <code>firstName</code> control will be updated, and the other controls (<code>lastName</code>, <code>email</code>) will remain unchanged.</p>"},{"location":"angular/forms/#difference-between-patchvalue-and-setvalue","title":"Difference Between <code>patchValue</code> and <code>setValue</code>","text":"Method Description Use Case setValue Updates all form controls in the form group or form array. When you need to update every form control's value at once. patchValue Updates only the provided controls in the form group or array. When you need to update only specific fields, leaving others unchanged."},{"location":"angular/forms/#real-world-scenarios-for-using-custom-validators-form-arrays-patchvalue-and-setvalue","title":"Real-World Scenarios for Using Custom Validators, Form Arrays, <code>patchValue</code>, and <code>setValue</code>","text":"Scenario Use Case Form Feature Email Validation Validating an email to ensure it comes from a specific domain. Custom Validator Dynamic Lists (Skills, Tags) Allowing users to add a list of skills or tags dynamically. FormArray Updating Multiple Form Controls Updating multiple fields in the form with data from an API response. <code>setValue</code> Updating Partial Form Values Patching only a part of a form, such as updating user profile details. <code>patchValue</code>"},{"location":"angular/forms/#summary_1","title":"Summary","text":"<ul> <li>Custom Validators allow you to create custom validation logic for form controls or groups.</li> <li>FormArrays are used to handle dynamic lists of form controls, such as a list of items or multiple choices.</li> <li><code>setValue</code> updates all the values in a form, while <code>patchValue</code> only updates the specified values, allowing partial updates.</li> <li>Use <code>patchValue</code> for flexible updates and <code>setValue</code> when you need to set all form values.</li> </ul> <p>Best Practice</p> <p>Use FormArrays for scenarios where the number of form controls is dynamic, such as adding/removing list items. Use <code>setValue</code> when you need to set all values, and <code>patchValue</code> when updating only specific form fields.</p>"},{"location":"angular/more/","title":"More","text":""},{"location":"angular/more/#angular-app-optimization","title":"Angular App optimization","text":"<p>https://www.scholarhat.com/tutorial/angular/tips-to-optimize-your-angular-application https://medium.com/@chandrabhushan1323/how-to-improve-angular-application-performance-fadde3890e71</p>"},{"location":"angular/more/#achieving-accessibility-and-seo-for-angular-apps","title":"Achieving Accessibility and SEO for Angular Apps","text":""},{"location":"angular/more/#accessibility-in-angular","title":"Accessibility in Angular","text":""},{"location":"angular/more/#what-is-accessibility","title":"What is Accessibility?","text":"<p>Answer: Accessibility in web development refers to creating websites and applications that can be used by all people, including those with disabilities. For Angular applications, ensuring accessibility means following best practices to ensure that users with visual, auditory, motor, and cognitive disabilities can interact with the app effectively.</p>"},{"location":"angular/more/#key-accessibility-concepts","title":"Key Accessibility Concepts","text":"<ul> <li> <p>Semantic HTML: Use meaningful HTML tags such as <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;article&gt;</code>, and <code>&lt;section&gt;</code> to ensure that screen readers and other assistive technologies can correctly interpret the structure of the page.</p> </li> <li> <p>ARIA (Accessible Rich Internet Applications): ARIA is a set of attributes that enhance accessibility for dynamic content and advanced user interface controls that might not be natively accessible.</p> <ul> <li>Examples of ARIA roles:<ul> <li><code>role=\"button\"</code> for buttons that are not standard <code>&lt;button&gt;</code> elements.</li> <li><code>aria-label=\"close\"</code> for labeling controls for screen readers.</li> <li><code>aria-hidden=\"true\"</code> to hide non-interactive elements from screen readers.</li> </ul> </li> </ul> </li> <li> <p>Keyboard Navigation: Ensure that users can navigate your application using only a keyboard. This includes providing clear focus states, managing focus order, and handling keyboard events (e.g., <code>Enter</code>, <code>Space</code>, <code>Tab</code>).</p> </li> <li> <p>Color Contrast and Text Size: Ensure that your application has a high color contrast ratio and allows for text resizing. Avoid relying solely on color to convey information.</p> </li> <li> <p>Error Messages and Validation: Provide clear, descriptive error messages for form validation. Use ARIA live regions for dynamic error updates so screen readers announce the changes.</p> </li> </ul>"},{"location":"angular/more/#angular-accessibility-best-practices","title":"Angular Accessibility Best Practices","text":"<ul> <li> <p>Use <code>ngAria</code> module: Angular has a built-in ngAria module to automatically add ARIA attributes to elements, making Angular applications more accessible.</p> </li> <li> <p>Focusable elements: Ensure elements like buttons, links, inputs, and custom controls are focusable. Use the <code>tabindex</code> attribute where necessary.</p> </li> <li> <p>Custom Components Accessibility: For custom components like modals, dropdowns, or sliders, use ARIA roles and attributes to make them accessible.</p> </li> </ul>"},{"location":"angular/more/#example-adding-aria-to-a-custom-button-component","title":"Example: Adding ARIA to a Custom Button Component","text":"<pre><code>&lt;button role=\"button\" aria-label=\"Submit Form\" (click)=\"submitForm()\"&gt;\n  Submit\n&lt;/button&gt;\n</code></pre>"},{"location":"angular/more/#example-ensuring-keyboard-navigation-for-a-modal","title":"Example: Ensuring Keyboard Navigation for a Modal","text":"<pre><code>@HostListener('keydown', ['$event'])\nonKeydown(event: KeyboardEvent) {\n  if (event.key === 'Escape') {\n    this.closeModal();\n  }\n}\n</code></pre>"},{"location":"angular/more/#tools-for-testing-accessibility","title":"Tools for Testing Accessibility","text":"<ul> <li>axe-core: A popular accessibility testing library that can be integrated into testing frameworks like Jasmine and Karma to automatically detect accessibility issues.</li> <li>Chrome Accessibility DevTools: Chrome DevTools provides built-in accessibility auditing tools.</li> </ul>"},{"location":"angular/more/#seo-for-angular-applications","title":"SEO for Angular Applications","text":""},{"location":"angular/more/#what-is-seo","title":"What is SEO?","text":"<p>Answer: SEO (Search Engine Optimization) refers to the practice of optimizing web pages so they rank higher in search engine results. For Angular applications, SEO is especially challenging because many applications rely heavily on client-side rendering, making it difficult for search engine crawlers to index dynamic content.</p>"},{"location":"angular/more/#key-seo-techniques-for-angular","title":"Key SEO Techniques for Angular","text":"<ul> <li> <p>Server-Side Rendering (SSR) with Angular Universal:    One of the most effective ways to improve SEO in Angular apps is by using Angular Universal for Server-Side Rendering (SSR). SSR generates the HTML content on the server, which is then sent to the browser. This ensures that search engine crawlers can index the fully rendered content.</p> <p>Benefits: - Faster initial load time. - Improved search engine indexing and crawling. - Better social media sharing previews (with rich previews).</p> </li> </ul>"},{"location":"angular/more/#example-setting-up-angular-universal-for-ssr","title":"Example: Setting up Angular Universal for SSR","text":"<pre><code>ng add @nguniversal/express-engine\nng serve:ssr  // Start SSR in development mode\n</code></pre> <ul> <li> <p>Meta Tags and SEO-friendly URLs:    Use Angular's Meta service to dynamically update meta tags for SEO. This includes the <code>&lt;title&gt;</code>, <code>&lt;meta&gt;</code> tags, and Open Graph tags for social media sharing.</p> <p>Use Meta and Title services to set title and description dynamically for different routes.</p> <pre><code>import { Meta, Title } from '@angular/platform-browser';\n\nconstructor(private meta: Meta, private title: Title) {}\n\nupdateMetaData() {\n  this.title.setTitle('New Page Title');\n  this.meta.updateTag({ name: 'description', content: 'Description of the page content' });\n}\n</code></pre> </li> <li> <p>Lazy Loading for SEO:    Use lazy loading to load modules only when needed, which improves the initial load time and overall performance of the app. SEO can be improved indirectly by ensuring faster load times, which contributes to better rankings.</p> </li> </ul> <p>Lazy loading is enabled by setting up routing with lazy-loaded modules.</p> <ul> <li>Sitemaps:    Create a sitemap.xml file that helps search engines discover all pages in the application. This is especially important for Single Page Applications (SPA) that might not have traditional page loads.</li> </ul> <p>Tools like angular-sitemap-generator can be used to automate sitemap generation.</p> <ul> <li>Structured Data:    Using structured data (JSON-LD or Microdata) helps search engines understand the content on the page more effectively, improving rich snippets in search results.</li> </ul>"},{"location":"angular/more/#example-adding-json-ld-schema-for-a-product-page","title":"Example: Adding JSON-LD schema for a product page","text":"<pre><code>&lt;script type=\"application/ld+json\"&gt;\n  {\n    \"@context\": \"http://schema.org\",\n    \"@type\": \"Product\",\n    \"name\": \"Product Name\",\n    \"description\": \"Product Description\",\n    \"image\": \"URL_to_image\",\n    \"offers\": {\n      \"@type\": \"Offer\",\n      \"priceCurrency\": \"USD\",\n      \"price\": \"99.99\"\n    }\n  }\n&lt;/script&gt;\n</code></pre> <ul> <li>SEO-friendly URLs:    Use clean, descriptive, and SEO-friendly URLs in your Angular app. Avoid using hash-based routing (/#/page) and prefer path-based routing (/page), which is more SEO-friendly.</li> </ul> <p>Angular\u2019s PathLocationStrategy supports clean URLs.</p>"},{"location":"angular/more/#common-interview-questions-on-seo-and-accessibility","title":"Common Interview Questions on SEO and Accessibility","text":"<ol> <li> <p>What is SSR and why is it important for SEO in Angular? Answer:    SSR (Server-Side Rendering) in Angular, achieved with Angular Universal, is the process of rendering content on the server and sending fully rendered HTML to the browser. It helps with SEO because search engines can crawl the fully rendered content, improving the page\u2019s visibility and ranking in search results.</p> </li> <li> <p>How do you make an Angular application accessible? Answer:    To ensure accessibility, you can:</p> </li> <li>Use semantic HTML and ARIA attributes.</li> <li>Ensure proper keyboard navigation.</li> <li>Maintain good color contrast and text resizing.</li> <li>Provide descriptive error messages and validation feedback.</li> <li> <p>Test with tools like axe-core and Chrome Accessibility DevTools.</p> </li> <li> <p>What is the difference between CSR and SSR in terms of SEO?</p> <ul> <li>CSR (Client-Side Rendering): In CSR, content is rendered on the client side, which makes it difficult for search engines to index content properly, as they see an empty page with JavaScript code.</li> <li>SSR (Server-Side Rendering): In SSR, content is rendered on the server before it is sent to the browser, ensuring that search engines can crawl and index the fully rendered content, improving SEO.</li> </ul> </li> <li> <p>How can you improve SEO in Angular if using SSR is not possible?</p> <ul> <li>Use meta tags dynamically through Angular's Meta and Title services.</li> <li>Implement lazy loading to improve load time and performance.</li> <li>Ensure that your URLs are clean and descriptive.</li> <li>Provide a sitemap to help search engines crawl the site.</li> </ul> </li> </ol>"},{"location":"angular/more/#real-world-scenario-for-accessibility-and-seo","title":"Real-World Scenario for Accessibility and SEO","text":"Feature Real-World Use Case Angular Implementation SEO for Blogs Blogs with dynamic content, where SEO is critical for attracting organic traffic. Implement SSR with Angular Universal and dynamic meta tags. E-commerce Websites Online stores need high SEO ranking for products and accessible features for all users. Use SSR for SEO, and implement ARIA for accessible product search and navigation. Government Websites Public websites that need to be accessible for people with disabilities and optimized for search engines. Apply ARIA for accessibility and SSR for better indexing and fast load times."},{"location":"angular/more/#summary","title":"Summary","text":"<ul> <li>Accessibility in Angular can be achieved using semantic HTML, ARIA attributes, and ensuring keyboard navigation and error handling.</li> <li>SEO in Angular apps can be improved by using Angular Universal for SSR, setting meta tags dynamically, creating sitemaps, and optimizing URLs.</li> <li>Implementing these techniques ensures better user experience and higher search engine rankings.</li> </ul>"},{"location":"angular/more/#server-side-rendering-ssr-and-internationalization-i18n-in-angular","title":"Server-Side Rendering (SSR) and Internationalization (i18n) in Angular","text":""},{"location":"angular/more/#server-side-rendering-ssr-in-angular","title":"Server-Side Rendering (SSR) in Angular","text":""},{"location":"angular/more/#what-is-ssr","title":"What is SSR?","text":"<p>Answer: Server-Side Rendering (SSR) refers to the technique of rendering Angular applications on the server rather than in the browser. In SSR, the application is initially rendered on the server, and the generated HTML is sent to the browser. Once the browser receives the HTML, it then loads Angular and takes over the client-side rendering, allowing the app to behave like a single-page application (SPA).</p>"},{"location":"angular/more/#benefits-of-ssr","title":"Benefits of SSR","text":"<ul> <li>Faster Initial Load: Since the content is pre-rendered on the server, the browser doesn't have to wait for Angular to compile and render the view.</li> <li>Improved SEO: Search engines can index the content more easily since they see the fully rendered HTML, not just an empty shell.</li> <li>Better Performance: SSR can improve the perceived performance of an application by rendering content on the server first, reducing the time to first meaningful paint.</li> <li>Social Media Previews: When sharing links on social platforms like Facebook or Twitter, the pre-rendered HTML makes it possible to show rich previews (e.g., images, text, etc.).</li> </ul>"},{"location":"angular/more/#how-does-ssr-work-in-angular","title":"How does SSR work in Angular?","text":"<p>Angular's SSR implementation is achieved through Angular Universal. Angular Universal is a set of tools and libraries that allow developers to render Angular applications on the server.</p> <ul> <li>Angular Universal: This is a platform for building server-side rendered Angular applications. It makes Angular apps capable of rendering HTML on the server side.</li> <li>Universal Module: The Angular app is modularized and can be executed on both the browser and server.</li> <li>Prerendering: Pre-rendering allows a snapshot of the static HTML to be generated for each route, making it easy to cache and serve the content quickly.</li> </ul>"},{"location":"angular/more/#example-setting-up-ssr-with-angular-universal","title":"Example: Setting up SSR with Angular Universal","text":"<pre><code>ng add @nguniversal/express-engine\nng serve:ssr  // Starts the server-side rendered Angular app\n</code></pre>"},{"location":"angular/more/#internationalization-i18n-in-angular","title":"Internationalization (i18n) in Angular","text":""},{"location":"angular/more/#what-is-internationalization-i18n","title":"What is Internationalization (i18n)?","text":"<p>Answer: Internationalization (i18n) is the process of designing an application so that it can be easily adapted to different languages and regions without requiring a major redesign. In Angular, i18n is supported through the Angular i18n module, allowing developers to create applications that can be translated and localized based on the user's locale (language and region).</p>"},{"location":"angular/more/#key-concepts-in-angular-i18n","title":"Key Concepts in Angular i18n","text":"<ul> <li>Locale: A locale is a combination of the language and region settings. For example, \"en-US\" for English (United States) and \"fr-FR\" for French (France).</li> <li>Translation: This refers to providing different translations for the application\u2019s text based on the selected locale.</li> <li>Localization (l10n): Localization is the adaptation of content, layout, and formatting according to a specific region or culture. This may involve adjusting currency formats, date formats, and more.</li> <li>I18n Pipes: Angular provides pipes like i18nSelect, i18nPlural, and date, which are used for translating content in templates and formatting data.</li> </ul>"},{"location":"angular/more/#how-does-angular-i18n-work","title":"How does Angular i18n work?","text":"<ul> <li> <p>Marking Text for Translation: In Angular, we use the <code>i18n</code> attribute to mark content that should be translated. These marked texts will be extracted and translated in the later process.</p> <pre><code>&lt;p i18n=\"description|meaning of the text\"&gt;Hello World!&lt;/p&gt;\n</code></pre> </li> <li> <p>Generating Translation Files: Once the content is marked for translation, Angular CLI can extract the marked content and create <code>.xlf</code> files (XML Localization Interchange File Format). These files contain all the text that needs to be translated.</p> <pre><code>ng extract-i18n\n</code></pre> </li> <li> <p>Translation: After extraction, the <code>.xlf</code> files are translated into different languages and then merged back into the app. This process can be automated or managed manually.</p> </li> <li> <p>Changing the Locale: The application can switch locales at runtime using Angular's <code>LOCALE_ID</code> or <code>TranslateService</code> for dynamic language switching.</p> </li> </ul>"},{"location":"angular/more/#example-of-angular-i18n-setup","title":"Example of Angular i18n Setup","text":"<ol> <li> <p>Marking Text for Translation</p> <pre><code>&lt;p i18n=\"welcome|message to show on homepage\"&gt;Welcome to the Angular App&lt;/p&gt;\n</code></pre> </li> <li> <p>Extracting Translation File</p> <pre><code>ng extract-i18n\n</code></pre> <p>This will generate a file like <code>messages.xlf</code> containing the text that needs to be translated.</p> </li> <li> <p>Providing Translations     Translate the <code>messages.xlf</code> file for different languages, for example, <code>messages.fr.xlf</code> for French.</p> </li> <li> <p>Configuring the Locale in Angular     In your Angular module, import the necessary locale and set it up:</p> <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule, registerLocaleData } from '@angular/common';\nimport localeFr from '@angular/common/locales/fr';\nimport { LOCALE_ID } from '@angular/core';\n\nregisterLocaleData(localeFr);\n\n@NgModule({\n  providers: [{ provide: LOCALE_ID, useValue: 'fr' }]\n})\nexport class AppModule {}\n</code></pre> <p>This sets the French locale for your Angular application.</p> </li> </ol>"},{"location":"angular/more/#common-interview-questions-on-ssr-and-i18n","title":"Common Interview Questions on SSR and i18n","text":"<ol> <li> <p>What is Server-Side Rendering (SSR) and how does it work in Angular? Answer:    Server-Side Rendering (SSR) is the process of rendering content on the server instead of the browser. In Angular, SSR is implemented using Angular Universal, which allows the application to be pre-rendered on the server before sending it to the browser. This improves SEO, performance, and allows for better social media previews.</p> </li> <li> <p>How does SSR improve SEO? Answer:    In traditional client-side rendering, search engine bots only see an empty HTML shell, making it difficult for them to index content. With SSR, the content is pre-rendered on the server, so search engine bots can crawl and index the fully rendered page, improving SEO.</p> </li> <li> <p>What is the difference between SSR and CSR (Client-Side Rendering)?</p> <ul> <li>SSR (Server-Side Rendering): The server generates the HTML content and sends it to the browser, which reduces the time to first meaningful paint and enhances SEO.</li> <li>CSR (Client-Side Rendering): The browser loads the JavaScript, and Angular renders the content on the client side. This can lead to slower initial loading times and poor SEO unless additional measures like pre-rendering are taken.</li> </ul> </li> <li> <p>What is Internationalization (i18n) in Angular? Answer:    Internationalization (i18n) in Angular allows the application to support multiple languages and regions. Angular provides tools to manage translations, formats, and content customization based on the user's locale. The i18n module helps developers build applications that are easily localized by marking text for translation, extracting translations, and configuring different locales.</p> </li> <li> <p>What is the difference between i18n and l10n?</p> <ul> <li>i18n (Internationalization): The process of designing the app so that it can support multiple languages and regions. This includes preparing the app to handle text translation, date formats, and other locale-specific information.</li> <li>l10n (Localization): The actual adaptation of the application content and design for a specific language or region, such as translating text and adjusting formats for currency, dates, and addresses.</li> </ul> </li> </ol>"},{"location":"angular/more/#real-world-scenarios-for-ssr-and-i18n","title":"Real-World Scenarios for SSR and i18n","text":"Scenario Use Case ngRx Usage SEO Optimization SSR can be used to render content on the server, making it crawlable by search engines. SSR ensures content is available to search engines. Multilingual Website Building a global application that needs to be displayed in multiple languages and regions. i18n helps translate and format content per locale. Social Media Sharing Pre-rendered content ensures rich previews are shown when links are shared on social media. SSR generates previewable content."},{"location":"angular/more/#summary_1","title":"Summary","text":"<p>SSR (Server-Side Rendering) is the process of rendering Angular applications on the server to improve initial load time, SEO, and social media previews. It is achieved with Angular Universal.</p> <p>Internationalization (i18n) is the process of preparing an Angular app to support multiple languages and locales. Angular provides tools like i18n pipes, locale settings, and translation file extraction for this.</p> <p>Best Practice</p> <p>For apps targeting multiple languages or global markets, i18n is essential to make your app adaptable. Use SSR when SEO and performance are critical, especially for content-heavy sites.</p>"},{"location":"angular/ngRx/","title":"ngRx in Angular - Interview Questions and Answers","text":"<p>Overview</p> <p>ngRx is a reactive state management library for Angular, inspired by Redux. It provides a predictable state container that helps in managing the application's state in a more maintainable and testable way. It uses Observables to manage the state, and provides a mechanism to handle actions, reducers, and effects to implement side effects.</p>"},{"location":"angular/ngRx/#what-is-ngrx","title":"What is ngRx?","text":"<p>Answer</p> <p>ngRx is a library for managing state in Angular applications. It allows developers to manage the application state in a centralized store using a unidirectional data flow. This pattern makes the application state predictable, manageable, and testable.</p> <p>ngRx is based on the principles of Redux and uses RxJS for reactive programming.</p>"},{"location":"angular/ngRx/#key-concepts-in-ngrx","title":"Key Concepts in ngRx","text":"<ol> <li> <p>Store:    The centralized place where the application's state is stored. It holds the data for the entire app in one global object.</p> </li> <li> <p>Actions:    Actions are dispatched to change the state. Each action has a type and can optionally carry a payload (additional data).</p> </li> <li> <p>Reducers:    Reducers are pure functions that determine how the state changes based on the dispatched action.</p> </li> <li> <p>Effects:    Effects handle side effects in ngRx, like API calls or asynchronous operations. They listen for actions and dispatch new actions based on results.</p> </li> <li> <p>Selectors:    Selectors are functions used to retrieve specific pieces of data from the store.</p> </li> </ol>"},{"location":"angular/ngRx/#ngrx-flow","title":"ngRx Flow","text":"<ol> <li>Action is dispatched (e.g., button click or form submission).</li> <li>Reducer handles the action and updates the store's state.</li> <li>Effect listens for specific actions to perform side effects like HTTP requests.</li> <li>Selector is used to retrieve data from the store.</li> </ol>"},{"location":"angular/ngRx/#example-of-using-ngrx","title":"Example of Using ngRx","text":""},{"location":"angular/ngRx/#1-define-actions","title":"1. Define Actions:","text":"<pre><code>import { createAction, props } from '@ngrx/store';\n\nexport const loadUsers = createAction('[User API] Load Users');\nexport const loadUsersSuccess = createAction('[User API] Load Users Success', props&lt;{ users: User[] }&gt;());\nexport const loadUsersFailure = createAction('[User API] Load Users Failure', props&lt;{ error: any }&gt;());\n</code></pre>"},{"location":"angular/ngRx/#ngrx-in-angular-interview-questions-and-answers_1","title":"ngRx in Angular - Interview Questions and Answers","text":""},{"location":"angular/ngRx/#define-reducers","title":"Define Reducers","text":"<p>Reducer Example</p> <p>In ngRx, reducers are pure functions that define how the application's state changes in response to actions. Below is an example of how to define a reducer:</p> <pre><code>import { createReducer, on } from '@ngrx/store';\nimport { loadUsersSuccess, loadUsersFailure } from './user.actions';\n\nexport interface UserState {\n  users: User[];\n  error: string;\n}\n\nexport const initialState: UserState = {\n  users: [],\n  error: '',\n};\n\nexport const userReducer = createReducer(\n  initialState,\n  on(loadUsersSuccess, (state, { users }) =&gt; ({ ...state, users })),\n  on(loadUsersFailure, (state, { error }) =&gt; ({ ...state, error }))\n);\n</code></pre>"},{"location":"angular/ngRx/#define-effects","title":"Define Effects","text":"<p>Effects Example</p> <p>Effects are used to handle side effects in ngRx, such as making HTTP requests. Below is an example of how to define an effect for loading users:</p> <pre><code>import { Injectable } from '@angular/core';\nimport { Actions, ofType } from '@ngrx/effects';\nimport { Observable, of } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport { UserService } from './user.service';\nimport { loadUsers, loadUsersSuccess, loadUsersFailure } from './user.actions';\n\n@Injectable()\nexport class UserEffects {\n  loadUsers$ = createEffect(() =&gt;\n    this.actions$.pipe(\n      ofType(loadUsers),\n      switchMap(() =&gt;\n        this.userService.getUsers().pipe(\n          map((users) =&gt; loadUsersSuccess({ users })),\n          catchError((error) =&gt; of(loadUsersFailure({ error })))\n        )\n      )\n    )\n  );\n\n  constructor(private actions$: Actions, private userService: UserService) {}\n}\n</code></pre>"},{"location":"angular/ngRx/#selectors","title":"Selectors","text":"<p>Selectors Example</p> <p>Selectors are functions used to retrieve specific pieces of state from the store. Here's an example of how to define selectors for the user state:</p> <pre><code>import { createSelector } from '@ngrx/store';\n\nexport const selectUserState = (state) =&gt; state.users;\n\nexport const selectAllUsers = createSelector(selectUserState, (state) =&gt; state.users);\n</code></pre>"},{"location":"angular/ngRx/#common-interview-questions-on-ngrx","title":"Common Interview Questions on ngRx","text":"<ol> <li> <p>What is ngRx and how does it work?</p> <p>Answer</p> <p>ngRx is a state management library for Angular based on Redux and RxJS. It works by maintaining a centralized store where the application\u2019s state resides. Actions are dispatched to modify the state, and reducers process these actions to update the store. Effects handle side effects like HTTP requests or navigation, and selectors are used to retrieve specific pieces of data from the store.</p> </li> <li> <p>What are the main parts of ngRx?</p> <p>Answer</p> <p>The key parts of ngRx are:</p> <ul> <li>Store: Holds the application state.</li> <li>Actions: Describe state changes.</li> <li>Reducers: Pure functions that update the state based on actions.</li> <li>Effects: Handle side effects (e.g., HTTP calls).</li> <li>Selectors: Retrieve pieces of the state.</li> </ul> </li> <li> <p>Explain the role of reducers in ngRx.</p> <p>Answer</p> <p>Reducers in ngRx are pure functions that determine how the state changes in response to actions. They take the current state and the action being dispatched, and return a new state object based on the action\u2019s type and payload.</p> </li> <li> <p>How do you handle side effects in ngRx?</p> <p>Answer</p> <p>Side effects, like API calls or navigation, are handled by Effects in ngRx. Effects listen for actions and perform side effects when those actions are dispatched. After completing the side effect, effects can dispatch new actions based on the result (e.g., success or failure).</p> </li> <li> <p>What is the purpose of selectors in ngRx?</p> <p>Answer</p> <p>Selectors are functions used to query the store and retrieve slices of state. They allow components to access specific pieces of data in the store, and are efficient because they can memoize values to avoid unnecessary recalculations.</p> </li> <li> <p>What is the difference between Store and BehaviorSubject in Angular?</p> <p>Answer</p> <ul> <li>Store: ngRx Store is a centralized state management system that follows a unidirectional data flow, where actions trigger state changes, and the state is accessible globally. It's a more scalable solution for large applications.</li> <li>BehaviorSubject: It is an RxJS class that acts like a subject but also stores the current value. While BehaviorSubject can hold a state, it doesn\u2019t have the structure, consistency, or tools (like effects and actions) that ngRx Store offers for complex applications.</li> </ul> </li> <li> <p>How do you test ngRx reducers and effects?</p> <p>Answer</p> <ul> <li>Testing Reducers: Reducers are pure functions, so they can be easily tested by dispatching actions and checking the resulting state.</li> </ul> <p>Example:</p> <pre><code>it('should return new state on loadUsersSuccess action', () =&gt; {\n  const action = loadUsersSuccess({ users: mockUsers });\n  const newState = userReducer(initialState, action);\n  expect(newState.users).toEqual(mockUsers);\n});\n</code></pre> <ul> <li>Testing Effects: ngRx effects can be tested using MockStore and Jasmine or Jest. You mock the services used in the effect and dispatch the action, checking if the correct actions are emitted.</li> </ul> <p>Example:</p> <pre><code>it('should load users on loadUsers action', () =&gt; {\n  const action = loadUsers();\n  const users = [{ name: 'John Doe' }];\n  const successAction = loadUsersSuccess({ users });\n\n  userService.getUsers.and.returnValue(of(users));\n\n  actions$ = hot('-a', { a: action });\n  const expected = cold('-b', { b: successAction });\n\n  expect(effects.loadUsers$).toBeObservable(expected);\n});\n</code></pre> </li> </ol>"},{"location":"angular/ngRx/#real-world-scenario-using-ngrx","title":"Real-World Scenario Using ngRx","text":"Scenario Use Case ngRx Usage Loading Data from API Fetching data from an external API and managing the loading, success, and error states. Actions, Reducers, Effects Managing User Authentication Storing the user's authentication status, user details, and permissions. Store, Actions, Reducers Handling Multi-step Form Managing form state across multiple steps, storing intermediate values. Store, Actions, Selectors Tracking Shopping Cart Managing a shopping cart with add/remove items and calculating totals. Store, Actions, Selectors"},{"location":"angular/ngRx/#summary","title":"Summary","text":"<p>Summary</p> <ul> <li>ngRx is a state management library based on Redux and RxJS, designed to manage application state in Angular applications.</li> <li>The key components are Store, Actions, Reducers, Effects, and Selectors.</li> <li>It follows a unidirectional data flow to manage state changes and side effects in a predictable manner.</li> <li>Effects manage asynchronous tasks like HTTP requests, while Reducers handle the actual state changes.</li> <li>ngRx simplifies managing complex application states in large-scale Angular applications.</li> </ul> <p>Best Practice</p> <p>Use ngRx for managing complex state logic and asynchronous operations, especially in large applications where scalability and maintainability are crucial.</p>"},{"location":"angular/optimizations/","title":"Optimzation","text":"Lazy Loading   Lazy Loading is an optimization technique in Angular that helps load JavaScript files and components only when they are required, instead of loading everything upfront. This can significantly reduce the initial load time of the application. By using Angular\u2019s `loadChildren` property in route configurations, we can load modules on demand. It improves performance, especially for larger applications.    **Example:**      const routes: Routes = [         {           path: 'feature',           loadChildren: () =&gt; import('./feature/feature.module').then(m =&gt; m.FeatureModule)         }       ];    AOT Compilation   Ahead-of-Time (AOT) Compilation is a technique where Angular compiles the application during the build process, rather than in the browser. This results in faster rendering as the application is already compiled into efficient JavaScript code. AOT also helps detect errors earlier and reduces the size of the final bundle.    **Example:**      To enable AOT in Angular, just run the build command with the `--aot` flag:      ng build --aot  Change Detection   Angular's change detection mechanism ensures that the view is updated whenever the model changes. Optimizing change detection can improve app performance. Using `ChangeDetectionStrategy.OnPush`, Angular will check for changes only when the input properties change, thus reducing the number of checks and improving performance.    **Example:**      @Component({         selector: 'app-user',         changeDetection: ChangeDetectionStrategy.OnPush,         templateUrl: './user.component.html'       })       export class UserComponent {         @Input() user: User;       }    trackBy for ngFor   The `trackBy` function in `ngFor` helps Angular track items by a unique identifier, improving performance in large lists. By default, Angular will re-render all items when the list changes. Using `trackBy`, Angular can only update the DOM for the changed items, which reduces unnecessary re-renders.    **Example:**      <ul> <li>{{ item.name }}</li> </ul>        trackById(index: number, item: any): number {         return item.id;  // Unique identifier for each item       }    Pure Pipes   A pure pipe is a pipe that only executes when its input data changes, not every time the component re-renders. This reduces unnecessary recalculations and enhances performance. Pure pipes are the default in Angular, and using them effectively can optimize the application's responsiveness.    **Example:**      @Pipe({         name: 'filter',         pure: true  // Pure pipe       })       export class FilterPipe implements PipeTransform {         transform(value: any[], searchTerm: string): any[] {           return value.filter(item =&gt; item.name.includes(searchTerm));         }       }    Tree Shaking   Tree shaking is a technique used during the build process to remove unused code from the final bundle. Angular uses tools like Webpack to analyze the codebase and eliminate code that isn't needed, which helps reduce the size of the JavaScript bundle and improves load times.    **Example:**      Simply ensure that the build is done in production mode:      ng build --prod      Webpack automatically removes unused code when you build with `--prod`.  Use Web Workers   Web Workers allow JavaScript code to run in the background on a separate thread, enabling complex calculations or data processing without blocking the main thread. This helps improve UI responsiveness, especially in applications with heavy computation or large data sets.    **Example:**      const worker = new Worker('./worker.js', { type: 'module' });        worker.onmessage = (event) =&gt; {         console.log('Worker response:', event.data);       };        worker.postMessage('Start work');  Optimize Images   Optimizing images ensures that images are delivered in the most efficient format and size. Using techniques like lazy loading, compression, and serving images in modern formats like WebP can significantly reduce load times and improve application performance, especially on mobile networks.    **Example:**       Optimize Component Rendering   Optimizing component rendering involves minimizing unnecessary DOM updates. By using change detection strategies like `OnPush`, leveraging `ngOnChanges` lifecycle hooks, and preventing unnecessary re-renders, you can ensure that components only re-render when absolutely necessary, improving overall performance.    **Example:**      @Component({       selector: 'app-profile',       changeDetection: ChangeDetectionStrategy.OnPush     })     export class ProfileComponent {       @Input() profile: Profile;     }  Optimize HTTP Requests   Optimizing HTTP requests involves reducing the number of requests made to the server, caching data where appropriate, and batching requests together. Using HTTP interceptors to manage request headers, retries, or caching strategies can help improve the responsiveness of an application.    **Example:**      @Injectable()     export class DataService {       private cache = new Map();        constructor(private http: HttpClient) {}        getData(url: string): Observable {         if (this.cache.has(url)) {           return of(this.cache.get(url));         } else {           return this.http.get(url).pipe(             tap(data =&gt; this.cache.set(url, data))           );         }       }     }  Optimize Template Expressions   Template expressions in Angular are evaluated frequently during change detection. To optimize performance, avoid complex expressions in templates. Instead, move logic to component methods or properties, and use the `OnPush` change detection strategy to minimize recalculations.    **Example:**      Instead of complex logic in templates:      <pre><code>&lt;div&gt;{{ calculateDiscount(price) }}&lt;/div&gt;  \n</code></pre>      **Move logic to component:**      <pre><code>export class ProductComponent {\n  price = 100;\n\n  calculateDiscount(price: number): number {\n    return price * 0.9;  // Apply discount\n  }\n}\n</code></pre> Prevent Memory Leaks   Memory leaks occur when objects are not properly cleaned up, leading to increased memory consumption over time. To prevent memory leaks, it\u2019s important to unsubscribe from observables, destroy timers, and remove event listeners when components are destroyed. Tools like `ngOnDestroy` and `takeUntil` can help manage this.    **Example:**      @Component({       selector: 'app-observable-example',       templateUrl: './observable-example.component.html'     })     export class ObservableExampleComponent implements OnDestroy {       private unsubscribe$ = new Subject();        ngOnInit() {         this.dataService.getData()           .pipe(takeUntil(this.unsubscribe$))           .subscribe(data =&gt; {             console.log(data);           });       }        ngOnDestroy() {         this.unsubscribe$.next();         this.unsubscribe$.complete();       }     }"},{"location":"angular/pipes-interceptors/","title":"Pipes-Intersceptors","text":"<ul> <li>Angular provides a set of commonly used pipes to simplify data transformation in templates.</li> </ul> Pipe Description Usage Example DatePipe Formats a date value `{{ today CurrencyPipe Formats a number as currency `{{ price DecimalPipe Formats a number to a decimal `{{ num PercentPipe Formats a number as a percentage `{{ ratio JsonPipe Converts an object to a JSON string `{{ user LowerCasePipe Transforms a string to lowercase `{{ name UpperCasePipe Transforms a string to uppercase `{{ name SlicePipe Extracts a portion of an array/string `{{ text AsyncPipe Unwraps and subscribes to Observable or Promise `{{ observableData$ TitleCasePipe Transforms a string to title case `{{ name"},{"location":"angular/pipes-interceptors/#1-datepipe-example-showing-current-date","title":"1. DatePipe Example (Showing Current Date)","text":"<p>*** Display the current date in a human-readable format on a dashboard.*</p> <pre><code>&lt;!-- In DashboardComponent --&gt;\n&lt;p&gt;Today's Date: {{ today | date:'fullDate' }}&lt;/p&gt;\nexport class DashboardComponent {\n  today: Date = new Date();\n}\nOutput:\nToday's Date: Wednesday, November 28, 2024\n</code></pre>"},{"location":"angular/pipes-interceptors/#2-currencypipe-example-e-commerce-website","title":"2. CurrencyPipe Example (E-commerce Website)","text":"<p>***Display product prices in a currency format. *</p> <pre><code>&lt;p&gt;Price: {{ product.price | currency:'USD':'symbol':'1.2-2' }}&lt;/p&gt;\nexport class ProductComponent {\n  product = { price: 1234.5 };\n}\nOutput:\nPrice: $1,234.50\n</code></pre>"},{"location":"angular/pipes-interceptors/#3-asyncpipe-example-fetching-data-from-an-api","title":"3. AsyncPipe Example (Fetching Data from an API)","text":"<p>***Display a list of users fetched asynchronously from an API. **</p> <pre><code>&lt;ul&gt;\n  &lt;li *ngFor=\"let user of users$ | async\"&gt;{{ user.name }}&lt;/li&gt;\n&lt;/ul&gt;\nexport class UserListComponent {\n  users$ = this.http.get&lt;User[]&gt;('https://api.example.com/users');\n  constructor(private http: HttpClient) {}\n}\n</code></pre>"},{"location":"angular/pipes-interceptors/#custom-pipes-in-angular","title":"Custom Pipes in Angular","text":""},{"location":"angular/pipes-interceptors/#abbreviationpipe","title":"AbbreviationPipe","text":"<p>*** When Angular's prebuilt pipes don't meet your requirements, you can create custom pipes.*</p> <ul> <li> <p>** Custom Pipe to Convert a String to Abbreviations**</p> </li> <li> <p>Scenario:  In a contact list, display the user's full name as initials.</p> </li> </ul> <pre><code>ng generate pipe customPipeName\n// abbreviation.pipe.ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'abbreviation'\n})\nexport class AbbreviationPipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) return '';\n    return value\n      .split(' ')\n      .map(word =&gt; word[0].toUpperCase())\n      .join('');\n  }\n}\n\n&lt;p&gt;User Initials: {{ user.name | abbreviation }}&lt;/p&gt;\n\nexport class UserComponent {\n  user = { name: 'John Doe' };\n}\nOutput:User Initials: JD\n</code></pre>"},{"location":"angular/pipes-interceptors/#truncate-pipe","title":"Truncate Pipe","text":"<ul> <li> <p>Scenario: Show a shortened version of a product description.</p> </li> <li> <p>Use Case:  .</p> </li> </ul> <pre><code>// truncate.pipe.ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'truncate'\n})\nexport class TruncatePipe implements PipeTransform {\n  transform(value: string, limit: number = 20): string {\n    return value.length &gt; limit ? value.substring(0, limit) + '...' : value;\n  }\n}\n&lt;p&gt;{{ product.description | truncate:30 }}&lt;/p&gt;\nexport class ProductComponent {\n  product = { description: 'This is a long product description that should be truncated.' };\n}\n\nOutput:\nThis is a long product des...\n</code></pre>"},{"location":"angular/pipes-interceptors/#safe-html-pipe-bypass-html-sanitization","title":"Safe HTML Pipe (Bypass HTML Sanitization)","text":"<ul> <li>**In a content management system, safely display raw HTML content. **</li> </ul> <pre><code>// safe-html.pipe.ts\nimport { Pipe, PipeTransform } from '@angular/core';\nimport { DomSanitizer, SafeHtml } from '@angular/platform-browser';\n\n@Pipe({\n  name: 'safeHtml'\n})\nexport class SafeHtmlPipe implements PipeTransform {\n  constructor(private sanitizer: DomSanitizer) {}\n\n  transform(value: string): SafeHtml {\n    return this.sanitizer.bypassSecurityTrustHtml(value);\n  }\n}\n\n&lt;div [innerHTML]=\"htmlContent | safeHtml\"&gt;&lt;/div&gt;\nexport class HtmlContentComponent {\n  htmlContent = '&lt;h1&gt;Welcome to our Website&lt;/h1&gt;&lt;p&gt;This is raw HTML content.&lt;/p&gt;';\n}\nOutput:\nThe HTML content is displayed safely without Angular's default sanitization blocking it.\n</code></pre>"},{"location":"angular/pipes-interceptors/#highlight-pipe","title":"Highlight Pipe","text":"<p>Note</p> <p>Scenario: Highlight search terms in a list of results.</p> <pre><code>// highlight.pipe.ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'highlight'\n})\nexport class HighlightPipe implements PipeTransform {\n  transform(text: string, search: string): string {\n    if (!search) return text;\n    const regex = new RegExp(`(${search})`, 'gi');\n    return text.replace(regex, `&lt;span class=\"highlight\"&gt;$1&lt;/span&gt;`);\n  }\n}\nUsage:\n\n&lt;p [innerHTML]=\"text | highlight:searchTerm\"&gt;&lt;/p&gt;\ntypescript\nCopy code\nexport class SearchComponent {\n  text = 'Angular is a popular framework for building web applications.';\n  searchTerm = 'Angular';\n}\nOutput:\nAngular is highlighted in the text.\n</code></pre>"},{"location":"angular/pipes-interceptors/#intersceptors","title":"Intersceptors","text":"<p>Intersceptors</p> <p>In Angular, HTTP Interceptors are a part of the HttpClient module and provide a way to intercept and modify HTTP requests and responses globally before they are sent to the server or after the server returns a response.</p> <p>Why Use Interceptors? Interceptors are useful for handling:</p> <p>Authentication Tokens (e.g., attaching JWT tokens to every request) Error Handling (e.g., catching errors globally) Logging (e.g., logging requests and responses) Request/Response Transformation (e.g., modifying request headers or responses)</p> <p>How Angular Interceptors Work Interceptors implement the HttpInterceptor interface and intercept HTTP requests using the intercept() method. They are registered globally in the providers array of an Angular module.</p> Use Case Description Authentication Attach JWT tokens or API keys to each request. Error Handling Catch and handle HTTP errors globally. Logging Log request and response details for debugging. Custom Headers Add custom headers required for API requests. Response Transformation Modify or transform the response before passing it to components. Network Delay Simulation Simulate slow network conditions for testing."},{"location":"angular/pipes-interceptors/#adding-authorization-token-to-http-requests","title":"Adding Authorization Token to HTTP Requests","text":"<p>Adding Authorization Token to HTTP Requests</p> <p>Scenario: In a banking application, every API request to the server requires a JWT token for authentication. Instead of manually adding the token to each request, an interceptor automatically appends the token.</p> <p>Implementation: <pre><code>// auth.interceptor.ts\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {\n    const authToken = 'Bearer ' + localStorage.getItem('authToken'); // Get token from localStorage\n\n    // Clone the request and add the Authorization header\n    const authReq = req.clone({\n      setHeaders: {\n        Authorization: authToken\n      }\n    });\n\n    return next.handle(authReq); // Pass the cloned request\n  }\n}\n</code></pre> <pre><code>Registering the Interceptor:\nAdd the interceptor to the providers array in your module.\n\n\n// app.module.ts\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { AuthInterceptor } from './auth.interceptor';\n\n@NgModule({\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: AuthInterceptor,\n      multi: true\n    }\n  ]\n})\nexport class AppModule {}\nResult: Every HTTP request automatically includes the Authorization token, ensuring secure communication with the backend.\n</code></pre></p>"},{"location":"angular/pipes-interceptors/#global-error-handling","title":"Global Error Handling","text":"<p> Global Error Handling</p> <p>Scenario: In an e-commerce application, handle HTTP errors globally and display user-friendly messages when the server returns an error (e.g., 404, 500).</p> <p>Implementation: <pre><code>Copy code\n// error.interceptor.ts\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { MatSnackBar } from '@angular/material/snack-bar';\n\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n  constructor(private snackBar: MatSnackBar) {}\n\n  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {\n    return next.handle(req).pipe(\n      catchError((error: HttpErrorResponse) =&gt; {\n        let errorMessage = 'An unknown error occurred!';\n        if (error.status === 404) {\n          errorMessage = 'Resource not found!';\n        } else if (error.status === 500) {\n          errorMessage = 'Internal server error!';\n        }\n\n        // Display error message using Snackbar\n        this.snackBar.open(errorMessage, 'Close', {\n          duration: 3000\n        });\n\n        return throwError(() =&gt; new Error(errorMessage));\n      })\n    );\n  }\n}\nResult: Whenever an HTTP error occurs, a user-friendly message is displayed using a Snackbar, improving the user experience.\n</code></pre></p>"},{"location":"angular/pipes-interceptors/#request-and-response-logging","title":"Request and Response Logging","text":"<p>Request and Response Logging</p> <p>Scenario: In a large-scale enterprise application, log every HTTP request and response for debugging and auditing purposes.</p> <p>Implementation: <pre><code>Copy code\n// logging.interceptor.ts\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LoggingInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {\n    console.log('Request:', req);\n\n    return next.handle(req).pipe(\n      tap(event =&gt; {\n        console.log('Response:', event);\n      })\n    );\n  }\n}\n</code></pre></p>"},{"location":"angular/pipes-interceptors/#adding-custom-headers","title":"Adding Custom Headers","text":"<p>Intersceptors\"Adding Custom Headers</p> <p>Scenario: In a healthcare application, every request must include a custom header for compliance with medical data regulations.</p> <p>Implementation: <pre><code>Copy code\n// headers.interceptor.ts\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeadersInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {\n    const modifiedReq = req.clone({\n      setHeaders: {\n        'X-Custom-Header': 'HealthcareApp'\n      }\n    });\n\n    return next.handle(modifiedReq);\n  }\n}\nResult: Every HTTP request includes the custom header, ensuring compliance with industry standards.\n</code></pre></p>"},{"location":"angular/promise/","title":"Promises in JavaScript - Interview Questions and Answers","text":"<p>Overview</p> <p>Promises are used for asynchronous programming in JavaScript. They represent the completion (or failure) of an asynchronous operation and its resulting value. Promises help manage asynchronous operations by avoiding callback hell and making code more readable and maintainable.</p>"},{"location":"angular/promise/#what-is-a-promise","title":"What is a Promise?","text":"<p>Answer: A Promise is an object representing the eventual completion or failure of an asynchronous operation. It is in one of three states:</p> <ul> <li>Pending: The initial state. The promise is still being executed.</li> <li>Fulfilled: The operation completed successfully.</li> <li>Rejected: The operation failed.</li> </ul>"},{"location":"angular/promise/#example-of-creating-a-promise","title":"Example of Creating a Promise:","text":"<pre><code>const myPromise = new Promise((resolve, reject) =&gt; {\n  const success = true;\n\n  if (success) {\n    resolve(\"Operation was successful!\");\n  } else {\n    reject(\"Operation failed!\");\n  }\n});\n\nmyPromise\n  .then(result =&gt; console.log(result))\n  .catch(error =&gt; console.error(error));\n</code></pre>"},{"location":"angular/promise/#promises-in-javascript","title":"Promises in JavaScript","text":"<p>Explanation</p> <p>In this example:</p> <ul> <li><code>resolve()</code> is called if the promise is successful.</li> <li><code>reject()</code> is called if the promise fails.</li> <li><code>.then()</code> is used to handle success, and <code>.catch()</code> handles errors.</li> </ul>"},{"location":"angular/promise/#common-interview-questions-on-promises","title":"Common Interview Questions on Promises","text":""},{"location":"angular/promise/#1-what-is-the-difference-between-a-callback-and-a-promise","title":"1. What is the difference between a callback and a promise?","text":"<p>Answer</p> <ul> <li>Callback: A function passed as an argument to another function and executed after some operation is completed. It can lead to callback hell, where nested callbacks make code harder to read and manage.</li> <li>Promise: An object representing the completion or failure of an asynchronous operation, which is easier to manage and chain. Promises make asynchronous code more readable and maintainable.</li> </ul> Feature Callback Promise Readability Hard to manage in nested or multiple callbacks. Promises allow chaining with <code>.then()</code> and <code>.catch()</code>. Error Handling Errors are handled by passing errors to callbacks. Errors are handled with <code>.catch()</code> for better control. Asynchronous Handling Requires multiple callbacks for multiple async tasks. Allows chaining of async operations."},{"location":"angular/promise/#2-what-are-the-states-of-a-promise","title":"2. What are the states of a Promise?","text":"<p>Answer</p> <p>A Promise can be in one of three states:</p> <ul> <li>Pending: Initial state. The asynchronous operation is still in progress.</li> <li>Fulfilled: The asynchronous operation completed successfully.</li> <li>Rejected: The asynchronous operation failed.</li> </ul>"},{"location":"angular/promise/#3-what-are-then-and-catch-methods","title":"3. What are <code>.then()</code> and <code>.catch()</code> methods?","text":"<p>Answer</p> <ul> <li><code>.then()</code> is used to handle the success response when the promise is fulfilled. It returns a new promise that resolves with the returned value.</li> <li><code>.catch()</code> is used to handle the error response when the promise is rejected.</li> </ul> <p>Example:</p> <pre><code>myPromise\n  .then(result =&gt; console.log(result))  // Handles success\n  .catch(error =&gt; console.error(error)); // Handles error\n</code></pre>"},{"location":"angular/promise/#4-what-is-promise-chaining","title":"4. What is Promise chaining?","text":"<p>Answer</p> <p>Promise chaining is the process of using multiple <code>.then()</code> methods on a promise, where each <code>.then()</code> returns a new promise. This allows for sequential asynchronous operations.</p> <p>Example:</p> <pre><code>fetchData()\n  .then(data =&gt; processData(data))   // first async operation\n  .then(processedData =&gt; saveData(processedData))  // second async operation\n  .catch(error =&gt; console.error(error));  // handle any error in the chain\n</code></pre>"},{"location":"angular/promise/#5-what-is-promiseall","title":"5. What is <code>Promise.all()</code>?","text":"<p>Answer</p> <p><code>Promise.all()</code> is a method that accepts an array of promises and returns a new promise that resolves when all of the promises in the array have resolved. If any of the promises are rejected, <code>Promise.all()</code> will immediately reject with the error of the first promise that fails.</p> <p>Example:</p> <pre><code>const promise1 = Promise.resolve(3);\nconst promise2 = Promise.resolve(4);\nconst promise3 = Promise.resolve(5);\n\nPromise.all([promise1, promise2, promise3])\n  .then(values =&gt; console.log(values))  // [3, 4, 5]\n  .catch(error =&gt; console.log(error));\n</code></pre>"},{"location":"angular/promise/#6-what-is-promiserace","title":"6. What is <code>Promise.race()</code>?","text":"<p>Answer</p> <p><code>Promise.race()</code> accepts an array of promises and returns a new promise that resolves or rejects as soon as the first promise in the array resolves or rejects. It \"races\" the promises.</p> <p>Example:</p> <pre><code>const promise1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 100, 'one'));\nconst promise2 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 200, 'two'));\n\nPromise.race([promise1, promise2])\n  .then(result =&gt; console.log(result))  // Output: 'one'\n  .catch(error =&gt; console.log(error));\n</code></pre>"},{"location":"angular/promise/#7-what-is-promiseallsettled","title":"7. What is <code>Promise.allSettled()</code>?","text":"<p>Answer</p> <p><code>Promise.allSettled()</code> accepts an array of promises and returns a promise that resolves after all promises have either been fulfilled or rejected, providing the results of all promises.</p> <p>Example:</p> <pre><code>const promise1 = Promise.resolve(1);\nconst promise2 = Promise.reject('error');\nconst promise3 = Promise.resolve(3);\n\nPromise.allSettled([promise1, promise2, promise3])\n  .then(results =&gt; console.log(results)); \n  // Output: \n  // [ { status: 'fulfilled', value: 1 },\n  //   { status: 'rejected', reason: 'error' },\n  //   { status: 'fulfilled', value: 3 }]\n</code></pre>"},{"location":"angular/promise/#8-what-is-promisefinally","title":"8. What is <code>Promise.finally()</code>?","text":"<p>Answer</p> <p><code>Promise.finally()</code> is used to execute a cleanup or final operation after a promise settles (either resolves or rejects), regardless of the outcome. It does not modify the promise chain's result.</p> <p>Example:</p> <pre><code>fetchData()\n  .then(data =&gt; processData(data))\n  .catch(error =&gt; handleError(error))\n  .finally(() =&gt; console.log('Cleanup after promise'));\n</code></pre>"},{"location":"angular/promise/#real-world-scenarios-for-using-promises","title":"Real-World Scenarios for Using Promises","text":"Scenario Use Case Promise Usage Fetching Data from API Making asynchronous HTTP requests to fetch data from a server. <code>fetch()</code> API wrapped in a Promise. Processing Multiple API Requests Making multiple API calls concurrently and waiting for all results. <code>Promise.all()</code> UI Interactions Waiting for user interactions before continuing with further operations. Promise chaining with UI events. Async File Operations Handling file reading/writing operations where the result is not immediately available. Promise-based async I/O operations. Timeout or Delay Handling Delaying a certain operation, like waiting for a certain time before taking action. <code>Promise.race()</code> with a timeout promise."},{"location":"angular/promise/#summary","title":"Summary","text":"<ul> <li>Promises represent the completion (or failure) of an asynchronous operation.</li> <li>They help to handle asynchronous code in a more readable way, avoiding callback hell.</li> <li>Key methods include <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code>, and utility methods like <code>Promise.all()</code>, <code>Promise.race()</code>, and <code>Promise.allSettled()</code> for handling multiple promises simultaneously.</li> <li>Promise chaining allows multiple asynchronous operations to run sequentially, while <code>Promise.all()</code> and <code>Promise.race()</code> are used to handle concurrent promises.</li> </ul> <p>Best Practice</p> <p>Use <code>Promise.all()</code> when you need all promises to resolve before continuing, and <code>Promise.race()</code> when you need the fastest result.</p>"},{"location":"angular/routing/","title":"Routing","text":"<p>Angular Routing</p> <p>Angular routing is a powerful feature that allows you to create single-page applications (SPAs) with multiple views without reloading the page. Here's an overview of the key concepts and components involved in Angular routing:</p> <ol> <li>Setting Up Angular Routing   When you create a new Angular application, you can set up routing by adding --routing to the Angular CLI command:</li> </ol> <p>bash</p> <p>ng new my-app --routing   This command generates a AppRoutingModule file for configuring routes.</p> <ol> <li>The Router Module   Import the RouterModule in the routing module to enable routing. It also provides directives like router-outlet and routerLink for navigation and displaying routed components.</li> </ol> <p>Example of a routing module:</p> <pre><code>import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { AboutComponent } from './about/about.component';\n\nconst routes: Routes = [\n  { path: '', redirectTo: '/home', pathMatch: 'full' },\n  { path: 'home', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n  { path: '**', component: NotFoundComponent }, // Wildcard route for a 404 page\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n3. Router Outlet\nThe &lt;router-outlet&gt; directive acts as a placeholder where routed components are displayed. Place it in your main app component template:\n\nhtml\n\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n4. Navigating with RouterLink and Programmatic Navigation\nUse routerLink in templates to navigate:\n\nhtml\n\n&lt;a routerLink=\"/home\"&gt;Home&lt;/a&gt;\n&lt;a routerLink=\"/about\"&gt;About&lt;/a&gt;\nAlternatively, navigate programmatically using the Router service:\n</code></pre> <pre><code>import { Router } from '@angular/router';\n\nconstructor(private router: Router) {}\n\ngoToAbout() {\n  this.router.navigate(['/about']);\n}\n</code></pre>"},{"location":"angular/routing/#route-parameters","title":"Route Parameters","text":"<p>Route Parameters</p> <p>Parameters can be added to routes for dynamic content. Use the ActivatedRoute service to access them.</p> <p>Define a route with a parameter:</p> <p><pre><code>{ path: 'user/:id', component: UserComponent }\n</code></pre>   Access the parameter in the component:</p> <pre><code>import { ActivatedRoute } from '@angular/router';\n\nconstructor(private route: ActivatedRoute) {}\n\nngOnInit() {\n  const userId = this.route.snapshot.paramMap.get('id');\n} \n</code></pre>"},{"location":"angular/routing/#child-routes","title":"Child Routes","text":"<p>Note</p> <pre><code>Use child routes to create nested routing within a component:\n</code></pre> <pre><code>const routes: Routes = [\n  { \n    path: 'dashboard', \n    component: DashboardComponent,\n    children: [\n      { path: 'settings', component: SettingsComponent },\n      { path: 'profile', component: ProfileComponent }\n    ]\n  }\n];\n</code></pre>"},{"location":"angular/routing/#lazy-loading","title":"Lazy Loading","text":"<p>Note</p> <p>Lazy loading allows you to load feature modules only when they are needed, optimizing performance. Define a module route with loadChildren:</p> <pre><code>const routes: Routes = [\n  { \n    path: 'admin',\n    loadChildren: () =&gt; import('./admin/admin.module').then(m =&gt; m.AdminModule)\n  }\n];\n</code></pre>"},{"location":"angular/routing/#route-guards","title":"Route Guards","text":"<p>Note</p> <p>Route guards control access to routes. Angular provides different types of guards:</p> <ul> <li>CanActivate: Checks if a user can access a route.</li> <li>CanActivateChild: Checks access to child routes.</li> <li>CanDeactivate: Checks if a user can leave a route.</li> <li>Resolve: Pre-fetches data before loading a route.   Example of a guard:</li> </ul> <pre><code>import { Injectable } from '@angular/core';\nimport { CanActivate } from '@angular/router';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthGuard implements CanActivate {\n  canActivate(): boolean {\n    // Replace with actual authentication check\n    return isAuthenticated();\n  }\n}\n</code></pre>"},{"location":"angular/routing/#handling-404s-wildcards","title":"Handling 404s (Wildcards)","text":"<p>Note</p> <p>Add a wildcard route to catch unmatched paths:</p> <pre><code>{ path: '**', component: PageNotFoundComponent }\n</code></pre>"},{"location":"angular/routing/#router-events","title":"Router Events","text":"<p>Note</p> <p>Angular's Router service emits various events during routing. You can subscribe to these to perform actions at specific routing stages:</p> <pre><code>import { Router, NavigationEnd } from '@angular/router';\n\nconstructor(private router: Router) {\n  this.router.events.subscribe((event) =&gt; {\n    if (event instanceof NavigationEnd) {\n      console.log('Navigation ended:', event);\n    }\n  });\n}\n</code></pre>"},{"location":"angular/routing/#route-resolvers","title":"Route Resolvers","text":"<p>Note</p> <p>Resolvers allow you to pre-fetch data before navigating to a route. This is useful for loading essential data upfront to avoid displaying partially-loaded views.</p> <pre><code>Define a resolver service:\n</code></pre> <p><pre><code>import { Injectable } from '@angular/core';\nimport { Resolve, ActivatedRouteSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { UserService } from './user.service';\n\n@Injectable({ providedIn: 'root' })\nexport class UserResolver implements Resolve&lt;User&gt; {\n  constructor(private userService: UserService) {}\n\n  resolve(route: ActivatedRouteSnapshot): Observable&lt;User&gt; {\n    return this.userService.getUser(route.paramMap.get('id'));\n  }\n} \n</code></pre>   Use it in your route configuration:</p> <p><pre><code>{ \n  path: 'user/:id', \n  component: UserComponent,\n  resolve: { user: UserResolver }\n}\n</code></pre>   Access the resolved data in the component:</p> <pre><code>ngOnInit() {\n  this.route.data.subscribe(data =&gt; {\n    this.user = data['user'];\n  });\n}\n</code></pre>"},{"location":"angular/routing/#preloading-modules","title":"Preloading Modules","text":"<p>Note</p> <p>Preloading improves performance by loading lazy-loaded modules in the background, so they're ready if needed. Angular provides built-in preloading strategies:</p> <p>NoPreloading (default): Modules are not preloaded.   PreloadAllModules: All lazy-loaded modules are preloaded.   Enable preloading in the RouterModule:</p> <pre><code>imports: [RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules })]\n</code></pre> <p>## Custom Preloading Strategy  !!! note          You can create a custom preloading strategy for more granular control over which modules to preload.</p> <pre><code>    Example of a custom preloading strategy:\n</code></pre> <p><pre><code>import { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nexport class CustomPreloadingStrategy implements PreloadingStrategy {\n  preload(route: Route, load: () =&gt; Observable&lt;any&gt;): Observable&lt;any&gt; {\n    return route.data &amp;&amp; route.data['preload'] ? load() : of(null);\n  }\n}\n</code></pre>   Configure it in the routing module:</p> <p><pre><code>const routes: Routes = [\n  { path: 'feature', loadChildren: () =&gt; import('./feature/feature.module').then(m =&gt; m.FeatureModule), data: { preload: true } }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes, { preloadingStrategy: CustomPreloadingStrategy })],\n  providers: [CustomPreloadingStrategy]\n})\nexport class AppRoutingModule {}\n</code></pre>   ## Route Animations   !!! note \"Route Animations\"         Angular allows you to animate transitions between routes, which enhances the user experience in complex applications.</p> <pre><code>    Example of a route animation:\n</code></pre> <pre><code>import { trigger, transition, style, animate } from '@angular/animations';\n\nexport const slideInAnimation = \n  trigger('routeAnimations', [\n    transition('* &lt;=&gt; *', [\n      style({ opacity: 0 }),\n      animate('500ms', style({ opacity: 1 }))\n    ])\n  ]);\nApply this animation to &lt;router-outlet&gt;:\n\nhtml\n\n&lt;div [@routeAnimations]=\"o.isActivated ? o.activatedRoute : ''\"&gt;\n  &lt;router-outlet #o=\"outlet\"&gt;&lt;/router-outlet&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"angular/routing/#multiple-router-outlets","title":"Multiple Router Outlets","text":"<p>Note</p> <p>For more complex layouts, you can define multiple router outlets, each with its own set of routes.</p> <pre><code>&lt;router-outlet name=\"primary\"&gt;&lt;/router-outlet&gt;\n&lt;router-outlet name=\"sidebar\"&gt;&lt;/router-outlet&gt;\nThen specify the outlets in your routes:\n</code></pre> <pre><code>const routes: Routes = [\n  { path: 'main', component: MainComponent, outlet: 'primary' },\n  { path: 'sidebar', component: SidebarComponent, outlet: 'sidebar' }\n];\n</code></pre>"},{"location":"angular/routing/#strategy","title":"Strategy","text":"<p>Strategy</p> <ol> <li> <p>Route Reuse Strategy   Angular provides a way to control the reuse of route components, which can be helpful for performance. You can implement a custom RouteReuseStrategy to cache certain components and improve loading times.</p> </li> <li> <p>Lazy Loading Modules with Custom Selectors   Instead of loading a module with the loadChildren property directly in the route, you can create custom functions that allow finer control, like conditionally loading modules based on user permissions.</p> </li> <li> <p>Hash-based Routing   By default, Angular uses HTML5 routing (e.g., /about). However, for certain cases like legacy server setups that don\u2019t support path-based routing, you can switch to hash-based routing (e.g., /#/about) using:</p> </li> </ol> <p><pre><code>RouterModule.forRoot(routes, { useHash: true })\n</code></pre>   ## Configuring Scroll Position Restoration   !!! note          By default, Angular does not restore scroll positions when navigating. You can enable scroll position restoration in RouterModule:</p> <p><pre><code>imports: [RouterModule.forRoot(routes, { scrollPositionRestoration: 'enabled' })]\n</code></pre>   This will scroll to the top on each navigation or restore to the previous position when the user navigates back.</p>"},{"location":"angular/routing/#router-testing","title":"Router Testing","text":"<p>!!! note          Test Angular routes to ensure expected navigation behavior. Use Angular\u2019s RouterTestingModule for routing in unit tests.</p> <p>Example:</p> <p><pre><code>import { RouterTestingModule } from '@angular/router/testing';\n\nTestBed.configureTestingModule({\n  imports: [RouterTestingModule.withRoutes(routes)]\n});\n</code></pre>   ## Handling Query Parameters and Fragments   !!! note          Query parameters (?key=value) and URL fragments (#section) are commonly used in URLs. To set query parameters:</p> <p><pre><code>this.router.navigate(['/route'], { queryParams: { filter: 'value' } });\n</code></pre>   And to access them in the component:</p> <p><pre><code>this.route.queryParams.subscribe(params =&gt; {\n  const filter = params['filter'];\n});\n</code></pre>   Similarly, for fragments:</p> <p><pre><code>this.router.navigate(['/route'], { fragment: 'section' });\n</code></pre>   By understanding these concepts, you can take full advantage of Angular's routing capabilities to build a highly interactive, optimized, and user-friendly application.</p>"},{"location":"angular/rxjs/","title":"RxJS (Reactive Extensions for JavaScript)","text":"<p>RxJS is a library for composing asynchronous and event-based programs by using observable sequences. It provides one core type, the Observable, satellite types (Observer, Schedulers, Subjects) and operators inspired by Array methods (map, filter, reduce, every, etc) to allow handling asynchronous events as collections.</p>"},{"location":"angular/rxjs/#key-concepts-in-rxjs","title":"Key Concepts in RxJS","text":"<p>ReactiveX combines the Observer pattern with the Iterator pattern and functional programming with collections to fill the need for an ideal way of managing sequences of events.</p> <p>The essential concepts in RxJS which solve async event management are:</p> <p>Note</p> <ul> <li>Observable: represents the idea of an invokable collection of future values or events.</li> <li>Observer: is a collection of callbacks that knows how to listen to values delivered by the Observable.</li> <li>Subscription: represents the execution of an Observable, is primarily useful for cancelling the execution.</li> <li>Operators: are pure functions that enable a functional programming style of dealing with collections with operations like map, filter, concat, reduce, etc.</li> <li>Subject: is equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.</li> <li>Schedulers: are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. setTimeout or requestAnimationFrame or others.</li> </ul>"},{"location":"angular/rxjs/#observables","title":"Observables","text":"<ul> <li>Observables are lazy Push collections of multiple values. </li> <li>What is Pull? In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself  is unaware of when the data will be delivered to the Consumer.</li> <li>What is Push? In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.</li> </ul> <p>## Key Differences Between Cold and Hot Observables</p> Feature Cold Observable   (observables) Hot (subjects)Observable Data Production Starts when a subscriber subscribes. Starts independently of subscribers. Execution Each subscriber has its own execution. Shared execution across subscribers. Data Sharing No sharing; each subscriber gets fresh data. Shared; all subscribers receive the same data. Analogy Watching a movie from the beginning. Watching a live TV broadcast. Examples HTTP requests, file reads, <code>from()</code> operator. Mouse events, WebSockets, <code>Subject</code>. Subscriber Timing Subscribers receive all emitted values. Late subscribers miss past values."},{"location":"angular/rxjs/#basic-example-observable-and-observer","title":"Basic Example: Observable and Observer","text":"<pre><code>import { Observable } from 'rxjs';\n\n// Create an Observable\nconst observable = new Observable((subscriber) =&gt; {\n  subscriber.next('Hello');\n  subscriber.next('RxJS');\n  subscriber.complete();\n});\n// Create an Observer\n* What is an Observer? An Observer is a consumer of values delivered by an Observable.\nconst observer = {\n  next: (value: string) =&gt; console.log('Next:', value),\n  error: (err: any) =&gt; console.error('Error:', err),\n  complete: () =&gt; console.log('Completed!'),\n};\n// Subscribe to the Observable\nobservable.subscribe(observer);\n</code></pre>"},{"location":"angular/rxjs/#rxjs-operators-and-real-life-examples","title":"RxJS Operators and Real-Life Examples","text":"<p>Note</p> <ul> <li>RxJS operators help manage and manipulate streams of data effectively. They are categorized based on their functionality.    Two types:</li> <li>A Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable stays unmodified.</li> <li>Creation Operators are the other kind of operator, which can be called as standalone functions to create a new Observable. For example: of(1, 2, 3) creates an observable that will emit 1, 2, and 3, one right after another. Creation operators will be discussed in more detail in a later section.</li> </ul>"},{"location":"angular/rxjs/#map","title":"Map","text":"<p>Map</p> <ul> <li>Transforms the data emitted by an observable.</li> <li>Scenario: Transforming API Data You need to fetch a list of users from an API and display their full names.</li> <li>Use Case: Converting raw API responses into a format suitable for the UI.</li> </ul> <pre><code>import { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nthis.http.get&lt;{ name: string; age: number }[]&gt;('/api/users').pipe(\n  map(users =&gt; users.filter(user =&gt; user.age &gt; 18))\n).subscribe(console.log);\n</code></pre>"},{"location":"angular/rxjs/#filter","title":"filter","text":"<p>filter</p> <ul> <li>**Filters the emitted values based on a condition. **</li> <li>Scenario: Filtering Search Results. You want to display only users whose age is above 18.</li> <li>Use Case: Displaying only relevant data based on certain conditions.</li> </ul> <pre><code>import { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nthis.http.get&lt;{ name: string; age: number }[]&gt;('/api/users').pipe(\n  map(users =&gt; users.filter(user =&gt; user.age &gt; 18))\n).subscribe(console.log);\n</code></pre>"},{"location":"angular/rxjs/#merge","title":"merge","text":"<p>merge</p> <ul> <li>** Merges multiple observables and emits values as they arrive.**</li> <li> <p>Scenario: Handling Multiple Event Sources You have a button and a keyboard shortcut that both trigger the same action.</p> </li> <li> <p>Use Case: Combines multiple event streams, allowing you to trigger the same action from different sources.</p> </li> </ul> <pre><code>import { fromEvent, merge } from 'rxjs';\n\nconst buttonClick$ = fromEvent(document.getElementById('button')!, 'click');\nconst keyPress$ = fromEvent(document, 'keydown');\n\nmerge(buttonClick$, keyPress$).subscribe(() =&gt; {\n  console.log('Action triggered!');\n});\n</code></pre>"},{"location":"angular/rxjs/#mergemap","title":"mergeMap","text":"<p>mergeMap</p> <ul> <li>** Maps to an observable and flattens multiple inner observables concurrently.**</li> <li> <p>Scenario: Fetching Related Data for Multiple Items. You fetch a list of users and then fetch details for each user.</p> </li> <li> <p>Use Case: Running multiple API requests concurrently for better performance.</p> </li> </ul> <pre><code>import { from } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\n\nthis.http.get&lt;number[]&gt;('/api/userIds').pipe(\n  mergeMap(ids =&gt; from(ids)),\n  mergeMap(id =&gt; this.http.get(`/api/users/${id}`))\n).subscribe(console.log);\n</code></pre>"},{"location":"angular/rxjs/#forkjoin","title":"forkJoin","text":"<p>forkJoin</p> <ul> <li>** Waits for multiple observables to complete and returns the final values.**</li> <li> <p>Scenario: Loading User Details from Multiple APIs.You need to load user profile data from multiple APIs simultaneously and display it after all requests are complete.</p> </li> <li> <p>Use Case: Executes multiple API calls in parallel and waits for all to complete before proceeding.</p> </li> </ul> <pre><code>import { forkJoin } from 'rxjs';\n\nforkJoin({\n  user: this.http.get('/api/user/1'),\n  orders: this.http.get('/api/user/1/orders'),\n  notifications: this.http.get('/api/user/1/notifications')\n}).subscribe(({ user, orders, notifications }) =&gt; {\n  this.user = user;\n  this.orders = orders;\n  this.notifications = notifications;\n});\n</code></pre>"},{"location":"angular/rxjs/#switchmap","title":"switchMap","text":"<p>switchMap</p> <ul> <li>** Switches to a new observable, canceling the previous one.**</li> <li> <p>Scenario: Search Autocomplete. Each keystroke triggers an API search, but only the latest request should be considered.</p> </li> <li> <p>Use Case: Canceling stale requests when new input arrives.</p> </li> </ul> <pre><code>import { fromEvent } from 'rxjs';\nimport { debounceTime, map, switchMap } from 'rxjs/operators';\n\nfromEvent(document.getElementById('search')!, 'input').pipe(\n  debounceTime(300),\n  map((event: any) =&gt; event.target.value),\n  switchMap(query =&gt; this.http.get(`/api/search?q=${query}`))\n).subscribe(console.log);\n</code></pre>"},{"location":"angular/rxjs/#debouncetime","title":"debounceTime","text":"<p>debounceTime</p> <ul> <li>** Emits a value only after a specified time has passed without another emission.**</li> <li>Scenario: User Input Validation. You validate an email address only after the user stops typing for 300ms.</li> <li>Use Case: Reducing API calls for frequent user input.</li> </ul> <pre><code>import { fromEvent } from 'rxjs';\nimport { debounceTime, map } from 'rxjs/operators';\n\nfromEvent(document.getElementById('email')!, 'input').pipe(\n  debounceTime(300),\n  map((event: any) =&gt; event.target.value)\n).subscribe(console.log);\n</code></pre>"},{"location":"angular/rxjs/#distinctuntilchanged","title":"distinctUntilChanged","text":"<p>distinctUntilChanged</p> <ul> <li>** Suppresses duplicate consecutive values.**</li> <li>Scenario: Preventing Duplicate API Calls. Only fetch data when the user changes the input.</li> <li>Use Case: Avoiding redundant API calls when the input hasn\u2019t changed.</li> </ul> <pre><code>import { fromEvent } from 'rxjs';\nimport { distinctUntilChanged, debounceTime, map } from 'rxjs/operators';\n\nfromEvent(document.getElementById('search')!, 'input').pipe(\n  debounceTime(300),\n  map((event: any) =&gt; event.target.value),\n  distinctUntilChanged(),\n  switchMap(query =&gt; this.http.get(`/api/search?q=${query}`))\n).subscribe(console.log);\n</code></pre>"},{"location":"angular/rxjs/#combinelatest","title":"combineLatest","text":"<p>combineLatest</p> <ul> <li>** Combines the latest values from multiple observables.**</li> <li>Scenario: Displaying Data from Multiple Inputs. You want to calculate and display the total price when the user selects a product and enters the quantity.</li> <li>Use Case: Synchronizing data from different sources.</li> </ul> <pre><code>import { combineLatest, fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst productPrice$ = fromEvent(document.getElementById('product')!, 'change').pipe(\n  map((event: any) =&gt; +event.target.value)\n);\nconst quantity$ = fromEvent(document.getElementById('quantity')!, 'input').pipe(\n  map((event: any) =&gt; +event.target.value)\n);\n\ncombineLatest([productPrice$, quantity$]).pipe(\n  map(([price, quantity]) =&gt; price * quantity)\n).subscribe(console.log);\n</code></pre>"},{"location":"angular/rxjs/#catcherror","title":"catchError","text":"<p>catchError</p> <ul> <li>**Handles errors emitted by an observable. **</li> <li>Scenario: Handling API Errors Gracefully.You want to display an error message when an API call fails.</li> <li>Use Case: Providing user-friendly error messages.</li> </ul> <pre><code>import { throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nthis.http.get('/api/data').pipe(\n  catchError(error =&gt; {\n    console.error('Error:', error);\n    return throwError(() =&gt; new Error('Failed to fetch data.'));\n  })\n).subscribe({\n  next: console.log,\n  error: err =&gt; console.log(err.message)\n});\n</code></pre>"},{"location":"angular/rxjs/#retry","title":"retry","text":"<p>retry</p> <ul> <li>**Retries a failed observable a specified number of times. **</li> <li> <p>Scenario: Retrying Failed API Requests.You want to retry a failed API request up to 3 times before showing an error.</p> </li> <li> <p>Use Case: Handling intermittent network failures by retrying requests.</p> </li> </ul> <pre><code>import { throwError } from 'rxjs';\nimport { retry, catchError } from 'rxjs/operators';\n\nthis.http.get('/api/data').pipe(\n  retry(3),\n  catchError(err =&gt; throwError(() =&gt; new Error('Failed after 3 retries.')))\n).subscribe({\n  next: console.log,\n  error: err =&gt; console.log(err.message)\n});\n</code></pre>"},{"location":"angular/rxjs/#take","title":"take","text":"<p>take</p> <ul> <li>**Emits only the first n values from an observable. **</li> <li> <p>Scenario: Polling API for a Limited Number of Times.You want to poll an API for updates every second but stop after 5 attempts.</p> </li> <li> <p>Use Case: Limits the number of times the observable emits, reducing unnecessary requests.</p> </li> </ul> <pre><code>import { interval } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\ninterval(1000).pipe(\n  take(5),\n  switchMap(() =&gt; this.http.get('/api/status'))\n).subscribe(console.log);\n</code></pre>"},{"location":"angular/rxjs/#startwith","title":"startWith","text":"<p>startWith</p> <ul> <li>** Emits an initial value before the source observable emits.**</li> <li> <p>Scenario: Setting Default State for a Loader.You have a data table that shows a loader until the API data is loaded.</p> </li> <li> <p>Use Case: Sets the default state (Loading...) before the API response arrives.</p> </li> </ul> <pre><code>import { of } from 'rxjs';\nimport { startWith } from 'rxjs/operators';\n\nthis.http.get('/api/data').pipe(\n  startWith('Loading...')\n).subscribe(response =&gt; {\n  if (response === 'Loading...') {\n    this.showLoader = true;\n  } else {\n    this.showLoader = false;\n    this.data = response;\n  }\n});\n</code></pre>"},{"location":"angular/rxjs/#zip","title":"zip","text":"<p>zip</p> <ul> <li>** Combines multiple observables and emits their values as an array.**</li> <li> <p>Scenario: Fetching Data for Related Entities.You need to fetch a list of users and their corresponding addresses, but only emit values when both have been retrieved.</p> </li> <li> <p>Use Case: Combines the data streams of users and their respective addresses in a synchronized manner.</p> </li> </ul> <pre><code>import { zip } from 'rxjs';\n\nzip(\n  this.http.get('/api/users'),\n  this.http.get('/api/addresses')\n).subscribe(([users, addresses]) =&gt; {\n  this.usersWithAddresses = users.map((user, index) =&gt; ({\n    ...user,\n    address: addresses[index]\n  }));\n});\n</code></pre>"},{"location":"angular/rxjs/#of","title":"of","text":"<p>of</p> <ul> <li>** Creates an observable that emits a set of values and completes immediately.**</li> <li> <p>Scenario: Displaying Static Data.You want to display static data such as a list of product categories without making an API call.</p> </li> <li> <p>Use Case: Use of to emit static or synchronous data that doesn't require external data fetching.</p> </li> </ul> <pre><code>import { of } from 'rxjs';\n\nconst categories$ = of(['Electronics', 'Books', 'Clothing']);\n\ncategories$.subscribe(categories =&gt; {\n  console.log(categories); // Output: ['Electronics', 'Books', 'Clothing']\n});\n</code></pre>"},{"location":"angular/rxjs/#from","title":"from","text":"<p>from</p> <ul> <li>**Creates an observable from an array, a promise, or an iterable. **</li> <li> <p>Scenario: Handling Data from a Promise. You have a function that returns a promise, and you want to convert it into an observable for easier handling.</p> </li> <li> <p>Use Case: Use from to convert arrays, promises, or iterable objects into observables.</p> </li> </ul> <pre><code>import { from } from 'rxjs';\n\nconst promise = fetch('/api/data').then(response =&gt; response.json());\n\nfrom(promise).subscribe(data =&gt; {\n  console.log(data);\n});\n</code></pre>"},{"location":"angular/rxjs/#_1","title":"RxJs","text":"<p>tap</p> <ul> <li>** Performs a side effect for each emission, such as logging or updating UI, without modifying the emitted value.**</li> <li> <p>Scenario: Logging API Response.You want to log the API response for debugging purposes but don\u2019t want to modify the data.</p> </li> <li> <p>Use Case: Use tap for logging, triggering side effects, or updating UI elements without affecting the data flow.</p> </li> </ul> <pre><code>import { tap } from 'rxjs/operators';\n\nthis.http.get('/api/data').pipe(\n  tap(response =&gt; console.log('API Response:', response))\n).subscribe(data =&gt; {\n  this.data = data;\n});\n</code></pre> operator Description use cases map Transforms the emitted value. Transforming API data to display full names. filter Emits only values that satisfy a condition. Filtering search results to show only users above 18. switchMap Cancels the previous observable and switches to the latest one. Real-time search autocomplete, canceling stale requests. mergeMap Flattens multiple inner observables concurrently. Fetching related data (e.g., user details) concurrently. concatMap Flattens multiple inner observables sequentially. Submitting form sections one after another. debounceTime Emits the latest value after a specified time. Reducing API calls for user input validation. distinctUntilChanged Emits values only if they are different from the previous one. Preventing duplicate API calls for unchanged input. combineLatest Combines the latest values from multiple observables. Calculating the total price from product and quantity inputs. catchError Catches errors in the observable stream and handles them. Displaying a user-friendly error message for API failures retry Retries a failed observable a specified number of times. Retrying failed API requests up to 3 times. of Creates an observable that emits a set of values. Displaying static data such as product categories."},{"location":"angular/rxjs/#subject","title":"Subject","text":"<p>Subject</p> <ul> <li> <p>** What is a Subject? An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.**</p> </li> <li> <p>** A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.**   </p> </li> </ul> <p>**It does not store the last emitted value, meaning new subscribers won\u2019t receive previous values.</p> <ul> <li> <p>Scenario: Event Emitter for User Actions. You want to emit events when a user clicks a button, and multiple components need to react to this event in real-time.</p> </li> <li> <p>Use Case: Use Subject when you need a multicast observable to broadcast events without retaining the last emitted value.</p> </li> </ul> <pre><code>import { Subject } from 'rxjs';\n\nconst userActionSubject = new Subject&lt;string&gt;();\n\n// Component A: Emits user action\nfunction onUserAction(action: string) {\n  userActionSubject.next(action);  // Emit the action\n}\n\n// Component B: Listens to user actions\nuserActionSubject.subscribe(action =&gt; {\n  console.log('Component B received action:', action);\n});\n\n// Component C: Listens to user actions\nuserActionSubject.subscribe(action =&gt; {\n  console.log('Component C received action:', action);\n});\n\n// Simulate user actions\nonUserAction('Button Clicked'); // Both Component B and C receive the action\n</code></pre>"},{"location":"angular/rxjs/#behaviour-subjects","title":"Behaviour Subjects","text":"<p>BehaviorSubject</p> <ul> <li>**A BehaviorSubject stores the latest value and emits it to new subscribers immediately upon subscription. **</li> <li> <p>Scenario: You want to store and broadcast the current user\u2019s authentication status across different components.</p> </li> <li> <p>Use Case:  Use BehaviorSubject when you need to maintain and broadcast the latest value to both current and future subscribers (e.g., user authentication, theme settings).</p> </li> </ul> <pre><code>import { BehaviorSubject } from 'rxjs';\n\nconst authStatus$ = new BehaviorSubject&lt;boolean&gt;(false);  // Initial state is 'logged out'\n\n// Component A: Updates authentication status\nfunction login() {\n  authStatus$.next(true);  // User is logged in\n}\n\n// Component B: Listens for authentication changes\nauthStatus$.subscribe(isLoggedIn =&gt; {\n  console.log('Component B - User is logged in:', isLoggedIn);\n});\n\n// Component C: Subscribes after login but still gets the last state\nauthStatus$.subscribe(isLoggedIn =&gt; {\n  console.log('Component C - User is logged in:', isLoggedIn);\n});\n\n// Simulate login\nlogin();  // Both Component B and C receive 'true'\n</code></pre>"},{"location":"angular/rxjs/#replay-subject","title":"Replay Subject","text":"<p>ReplaySubject</p> <ul> <li>**A ReplaySubject emits a specified number of previous values to new subscribers, even if they subscribed after those values were emitted. **</li> <li> <p>Scenario: Chat Application. You want a component to receive the last 3 messages in a chatroom, even if the component joins after the messages were sent.</p> </li> <li> <p>Use Case: Use ReplaySubject when you want to replay a specified number of previous values to new subscribers (e.g., chat history, recent notifications).</p> </li> </ul> <pre><code>import { ReplaySubject } from 'rxjs';\n\nconst chatMessages$ = new ReplaySubject&lt;string&gt;(3);  // Replay the last 3 messages\n\n// User A sends messages\nchatMessages$.next('Hello!');\nchatMessages$.next('How are you?');\nchatMessages$.next('What are you doing?');\n\n// New subscriber (User B) joins and receives the last 3 messages\nchatMessages$.subscribe(message =&gt; {\n  console.log('User B received:', message);\n});\n\n// User B receives all 3 messages: 'Hello!', 'How are you?', 'What are you doing?'\n</code></pre>"},{"location":"angular/rxjs/#async-subjects","title":"Async Subjects","text":"<p>Async Subjects</p> <ul> <li>**An AsyncSubject emits only the last value and only when the observable completes. **</li> <li> <p>Scenario: API Request with Caching.you make an expensive API request, and you want all subscribers to receive the same final result when the request completes.</p> </li> <li> <p>Use Case:  Use AsyncSubject when you only care about the final value after completion (e.g., caching API results, configuration loading).</p> </li> </ul> <pre><code>import { AsyncSubject } from 'rxjs';\n\nconst apiResponse$ = new AsyncSubject&lt;number&gt;();\n\n// Simulate an API call\nsetTimeout(() =&gt; {\n  apiResponse$.next(42);  // Emit final result\n  apiResponse$.complete();  // Complete the observable\n}, 3000);\n\n// Subscriber A subscribes before completion\napiResponse$.subscribe(response =&gt; {\n  console.log('Subscriber A received:', response);\n});\n\n// Subscriber B subscribes after completion but still receives the final value\nsetTimeout(() =&gt; {\n  apiResponse$.subscribe(response =&gt; {\n    console.log('Subscriber B received:', response);\n  });\n}, 4000);\n</code></pre> Subject Type    Behavior Use Case Example Scenario Subject Multicasts values to multiple subscribers but does not store the last value. Event emitter for user actions. Broadcasting button clicks to components. BehaviorSubject Stores the latest value and emits it to new subscribers immediately. Maintaining state and broadcasting changes. User authentication or theme settings. ReplaySubject Replays a specified number of previous values to new subscribers. Providing history or recent data. Chat messages or recent notifications. AsyncSubject Emits only the final value and only after the observable completes. Caching or handling the result of a single operation. API request caching or configuration loading."},{"location":"angular/share-data/","title":"Share Data between Components","text":"Communication Type Use Case Data Direction @Input() Pass data from parent to child Parent \u2192 Child @Output() Emit event from child to parent Child \u2192 Parent @ViewChild() Access child component (single) Parent \u2192 Child @ViewChildren() Access multiple child components Parent \u2192 Child @ContentChild() Access single projected content Parent \u2192 Child @ContentChildren() Access multiple projected contents Parent \u2192 Child Subject Share data across unrelated components Any \u2192 Any ng-content Project content into a child Parent \u2192 Child"},{"location":"angular/share-data/#comparison-of-methods","title":"Comparison of Methods","text":"Communication Scenario Recommended Method Efficiency Rating   Complexity Parent to Child @Input() \u2b50\u2b50\u2b50\u2b50\u2b50 Low Child to Parent @Output() \u2b50\u2b50\u2b50\u2b50\u2b50 Low Sibling or Unrelated Components Service with BehaviorSubject \u2b50\u2b50\u2b50\u2b50    Medium Application-Wide State NgRx, Akita, or NGXS \u2b50\u2b50\u2b50\u2b50  High Content Projection ng-content    \u2b50\u2b50\u2b50\u2b50    Low Passing Data via URL Router Parameters \u2b50\u2b50\u2b50\u2b50  Medium Content Projection ng-content \u2b50\u2b50\u2b50\u2b50  Low Direct DOM Manipulation ElementRef + Renderer2 \u2b50\u2b50\u2b50   Medium"},{"location":"angular/share-data/#1-input-parent-to-child-communication","title":"1. Input() (Parent to Child Communication)","text":"<ul> <li> <p>Scenario: You have a ProductListComponent that displays a list of products. When you click on a product, the product details are passed to the ProductDetailsComponent to display more information.</p> </li> <li> <p>Use Case:  A parent component passes data to a child component..</p> </li> </ul> <pre><code>// parent component (ProductListComponent)\n@Component({\n  selector: 'app-product-list',\n  template: `\n    &lt;app-product-details [product]=\"selectedProduct\"&gt;&lt;/app-product-details&gt;\n    &lt;button (click)=\"selectProduct(product)\"&gt;View Details&lt;/button&gt;\n  `\n})\nexport class ProductListComponent {\n  selectedProduct: Product | undefined;\n\n  selectProduct(product: Product) {\n    this.selectedProduct = product;\n  }\n}\n// child component (ProductDetailsComponent)\n@Component({\n  selector: 'app-product-details',\n  template: `\n    &lt;div *ngIf=\"product\"&gt;\n      &lt;h2&gt;{{ product.name }}&lt;/h2&gt;\n      &lt;p&gt;{{ product.description }}&lt;/p&gt;\n    &lt;/div&gt;\n  `\n})\nexport class ProductDetailsComponent {\n  @Input() product!: Product;\n}\n</code></pre>"},{"location":"angular/share-data/#2-output-child-to-parent-communication","title":"2. Output() (Child to Parent Communication)","text":"<ul> <li> <p>Scenario: A SearchBarComponent emits the search query to the ProductListComponent to filter the product list.</p> </li> <li> <p>Use Case: A child component emits an event to the parent component. .</p> </li> </ul> <pre><code>// child component (SearchBarComponent)\n@Component({\n  selector: 'app-search-bar',\n  template: `\n    &lt;input type=\"text\" (input)=\"onSearch($event.target.value)\" placeholder=\"Search products\"&gt;\n  `\n})\nexport class SearchBarComponent {\n  @Output() searchQuery = new EventEmitter&lt;string&gt;();\n\n  onSearch(query: string) {\n    this.searchQuery.emit(query);\n  }\n}\n\n// parent component (ProductListComponent)\n@Component({\n  selector: 'app-product-list',\n  template: `\n    &lt;app-search-bar (searchQuery)=\"filterProducts($event)\"&gt;&lt;/app-search-bar&gt;\n    &lt;div *ngFor=\"let product of filteredProducts\"&gt;{{ product.name }}&lt;/div&gt;\n  `\n})\nexport class ProductListComponent {\n  filteredProducts: Product[] = [];\n\n  filterProducts(query: string) {\n    // Filter logic here\n  }\n}\n</code></pre>"},{"location":"angular/share-data/#viewchild-parent-accessing-child","title":"ViewChild() (Parent Accessing Child)","text":"<ul> <li> <p>Scenario: A FormComponent has a ChildInputComponent, and the parent needs to reset the form input.</p> </li> <li> <p>Use Case:  A parent component accesses a child component's properties or methods..</p> </li> </ul> <pre><code>// child component (ChildInputComponent)\n@Component({\n  selector: 'app-child-input',\n  template: `&lt;input type=\"text\" #inputBox&gt;`\n})\nexport class ChildInputComponent {\n  reset() {\n    this.inputBox.nativeElement.value = '';\n  }\n\n  @ViewChild('inputBox') inputBox!: ElementRef;\n}\n\n// parent component (FormComponent)\n@Component({\n  selector: 'app-form',\n  template: `\n    &lt;app-child-input&gt;&lt;/app-child-input&gt;\n    &lt;button (click)=\"resetInput()\"&gt;Reset&lt;/button&gt;\n  `\n})\nexport class FormComponent {\n  @ViewChild(ChildInputComponent) childInput!: ChildInputComponent;\n\n  resetInput() {\n    this.childInput.reset();\n  }\n}\n</code></pre>"},{"location":"angular/share-data/#viewchildren-access-multiple-child-components","title":"ViewChildren() (Access Multiple Child Components)","text":"<ul> <li> <p>Scenario: Access multiple child components.</p> </li> <li> <p>Use Case:  A TabContainerComponent manages multiple TabComponent instances..</p> </li> </ul> <pre><code>// child component (TabComponent)\n@Component({\n  selector: 'app-tab',\n  template: `&lt;ng-content&gt;&lt;/ng-content&gt;`\n})\nexport class TabComponent {}\n\n// parent component (TabContainerComponent)\n@Component({\n  selector: 'app-tab-container',\n  template: `\n    &lt;app-tab&gt;&lt;/app-tab&gt;\n    &lt;app-tab&gt;&lt;/app-tab&gt;\n    &lt;button (click)=\"logTabs()\"&gt;Log Tabs&lt;/button&gt;\n  `\n})\nexport class TabContainerComponent {\n  @ViewChildren(TabComponent) tabs!: QueryList&lt;TabComponent&gt;;\n\n  logTabs() {\n    console.log(this.tabs.length); // Logs number of tabs\n  }\n}\n</code></pre>"},{"location":"angular/share-data/#_1","title":"Share Data between Components","text":"<ul> <li> <p>Scenario: </p> </li> <li> <p>Use Case:  .</p> </li> </ul>"},{"location":"angular/share-data/#5-contentchild-access-projected-content","title":"5. ContentChild() (Access Projected Content)","text":"<ul> <li> <p>Scenario: A ModalComponent accesses a projected title from the parent.</p> </li> <li> <p>Use Case:  Access a single projected child element..</p> </li> </ul> <pre><code>// modal component (ModalComponent)\n@Component({\n  selector: 'app-modal',\n  template: `&lt;ng-content&gt;&lt;/ng-content&gt;`\n})\nexport class ModalComponent {\n  @ContentChild('title') title!: ElementRef;\n}\n\n// parent component (AppComponent)\n@Component({\n  selector: 'app-root',\n  template: `\n    &lt;app-modal&gt;\n      &lt;h1 #title&gt;Modal Title&lt;/h1&gt;\n    &lt;/app-modal&gt;\n  `\n})\nexport class AppComponent {}\n</code></pre>"},{"location":"angular/share-data/#6-contentchildren-access-multiple-projected-content-elements","title":"6. ContentChildren() (Access Multiple Projected Content Elements)","text":"<ul> <li> <p>Scenario: ContentChildren() (Access Multiple Projected Content Elements)</p> </li> <li> <p>Use Case:  Access multiple projected children..</p> </li> </ul> <pre><code>@Component({\n  selector: 'app-list',\n  template: `\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;button (click)=\"logItems()\"&gt;Log Items&lt;/button&gt;\n  `\n})\nexport class ListComponent {\n  @ContentChildren('item') items!: QueryList&lt;ElementRef&gt;;\n\n  logItems() {\n    console.log(this.items.length); // Logs the number of items\n  }\n}\n</code></pre>"},{"location":"angular/share-data/#7-subject-observable-pattern-cross-component-communication","title":"7. Subject (Observable Pattern) (Cross-Component Communication)","text":"<ul> <li> <p>Scenario: A UserService shares login status between NavbarComponent and SidebarComponent.</p> </li> <li> <p>Use Case:  Share data between unrelated components..</p> </li> </ul> <pre><code>// service (UserService)\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private loginStatus = new Subject&lt;boolean&gt;();\n\n  loginStatus$ = this.loginStatus.asObservable();\n\n  updateLoginStatus(status: boolean) {\n    this.loginStatus.next(status);\n  }\n}\n\n// component (NavbarComponent)\n@Component({\n  selector: 'app-navbar',\n  template: `{{ isLoggedIn ? 'Logout' : 'Login' }}`\n})\nexport class NavbarComponent {\n  isLoggedIn = false;\n\n  constructor(private userService: UserService) {\n    this.userService.loginStatus$.subscribe(status =&gt; {\n      this.isLoggedIn = status;\n    });\n  }\n}\n</code></pre>"},{"location":"angular/share-data/#8-ng-content-content-projection","title":"8. ng-content (Content Projection)","text":"<ul> <li> <p>Scenario: A CardComponent accepts content for a header, body, and footer.</p> </li> <li> <p>Use Case:  Pass markup from a parent to a child component..</p> </li> </ul> <pre><code>// child component (CardComponent)\n@Component({\n  selector: 'app-card',\n  template: `\n    &lt;div class=\"card\"&gt;\n      &lt;ng-content select=\"[header]\"&gt;&lt;/ng-content&gt;\n      &lt;ng-content select=\"[body]\"&gt;&lt;/ng-content&gt;\n      &lt;ng-content select=\"[footer]\"&gt;&lt;/ng-content&gt;\n    &lt;/div&gt;\n  `\n})\nexport class CardComponent {}\n\n&lt;!-- parent component --&gt;\n&lt;app-card&gt;\n  &lt;div header&gt;Card Header&lt;/div&gt;\n  &lt;div body&gt;Card Body&lt;/div&gt;\n  &lt;div footer&gt;Card Footer&lt;/div&gt;\n&lt;/app-card&gt;\n</code></pre>"},{"location":"angular/share-data/#9-service-with-behaviorsubject-cross-component-communication-with-state-management","title":"9. Service with BehaviorSubject (Cross-Component Communication with State Management)","text":"<ul> <li> <p>Scenario: A CartService tracks items added to the cart and updates both the NavbarComponent (showing the cart icon with the number of items) and the CartComponent (displaying the list of items).</p> </li> <li> <p>Use Case: Maintain shared state across multiple components in a more reactive way. .</p> </li> </ul> <pre><code>// cart.service.ts\n@Injectable({ providedIn: 'root' })\nexport class CartService {\n  private cartItems = new BehaviorSubject&lt;Product[]&gt;([]);\n  cartItems$ = this.cartItems.asObservable();\n\n  addItem(product: Product) {\n    const currentItems = this.cartItems.value;\n    this.cartItems.next([...currentItems, product]);\n  }\n}\n\n// component (NavbarComponent)\n@Component({\n  selector: 'app-navbar',\n  template: `&lt;span&gt;Cart ({{ itemCount }})&lt;/span&gt;`\n})\nexport class NavbarComponent {\n  itemCount = 0;\n\n  constructor(private cartService: CartService) {\n    this.cartService.cartItems$.subscribe(items =&gt; {\n      this.itemCount = items.length;\n    });\n  }\n}\n</code></pre>"},{"location":"angular/share-data/#11-local-storage-session-storage-browser-storage-for-persisting-data","title":"11. Local Storage / Session Storage (Browser Storage for Persisting Data)","text":"<ul> <li> <p>Scenario: Storing user preferences such as theme selection (dark mode or light mode) and sharing it across components.</p> </li> <li> <p>Use Case:  Persist data between component interactions or page reloads..</p> </li> </ul> <pre><code>// theme.service.ts\n@Injectable({ providedIn: 'root' })\nexport class ThemeService {\n  setTheme(theme: string) {\n    localStorage.setItem('theme', theme);\n  }\n\n  getTheme(): string {\n    return localStorage.getItem('theme') || 'light';\n  }\n}\n// component (AppComponent)\n@Component({\n  selector: 'app-root',\n  template: `\n    &lt;button (click)=\"toggleTheme()\"&gt;Toggle Theme&lt;/button&gt;\n  `\n})\nexport class AppComponent {\n  constructor(private themeService: ThemeService) {}\n\n  toggleTheme() {\n    const currentTheme = this.themeService.getTheme();\n    const newTheme = currentTheme === 'light' ? 'dark' : 'light';\n    this.themeService.setTheme(newTheme);\n  }\n}\n</code></pre>"},{"location":"angular/share-data/#13-router-route-parameters-and-query-parameters-data-sharing-via-url","title":"13. Router (Route Parameters and Query Parameters) (Data Sharing via URL)","text":"<ul> <li> <p>Scenario: Pass a product ID from a ProductListComponent to a ProductDetailsComponent through the route.</p> </li> <li> <p>Use Case:  Pass data through the URL when navigating between components..</p> </li> </ul> <pre><code>// product-list.component.ts\n@Component({\n  selector: 'app-product-list',\n  template: `\n    &lt;a [routerLink]=\"['/product', product.id]\"&gt;View Details&lt;/a&gt;\n  `\n})\nexport class ProductListComponent {\n  product = { id: 1, name: 'Product A' };\n}\n// product-details.component.ts\n@Component({\n  selector: 'app-product-details',\n  template: `\n    &lt;div&gt;Product ID: {{ productId }}&lt;/div&gt;\n  `\n})\nexport class ProductDetailsComponent {\n  productId!: number;\n\n  constructor(private route: ActivatedRoute) {\n    this.route.params.subscribe(params =&gt; {\n      this.productId = +params['id'];\n    });\n  }\n}\n</code></pre>"},{"location":"angular/share-data/#14-hostlistener-listening-to-events-from-parent-or-host-component","title":"14. @HostListener (Listening to Events from Parent or Host Component)","text":"<ul> <li> <p>Scenario: A ScrollSpyDirective listens to scroll events to highlight the active section in a navbar.</p> </li> <li> <p>Use Case:  Listen for events triggered on the host element or parent component..</p> </li> </ul> <pre><code>@Directive({\n  selector: '[appScrollSpy]'\n})\nexport class ScrollSpyDirective {\n  @HostListener('window:scroll', ['$event'])\n  onScroll(event: Event) {\n    // Scroll logic here\n    console.log('Scrolling...');\n  }\n}\n</code></pre>"},{"location":"angular/share-data/#15-elementref-with-renderer2-direct-dom-manipulation","title":"15. ElementRef with Renderer2 (Direct DOM Manipulation)","text":"<ul> <li> <p>Scenario: A TooltipDirective shows a tooltip when hovering over a button.</p> </li> <li> <p>Use Case:  Pass data or interact with the DOM directly between components..</p> </li> </ul> <pre><code>@Directive({\n  selector: '[appTooltip]'\n})\nexport class TooltipDirective {\n  constructor(private el: ElementRef, private renderer: Renderer2) {}\n\n  @HostListener('mouseenter') onMouseEnter() {\n    const tooltip = this.renderer.createElement('span');\n    this.renderer.appendChild(this.el.nativeElement, tooltip);\n  }\n}\n</code></pre>"},{"location":"angular/testing/","title":"Angular Testing Interview Questions and Answers (Karma &amp; Jasmine)","text":"<p>Overview</p> <p>Testing in Angular is essential to ensure the quality, reliability, and performance of an application. Karma is the default test runner, and Jasmine is the testing framework used for unit testing Angular applications.</p>"},{"location":"angular/testing/#general-questions-on-angular-testing","title":"General Questions on Angular Testing","text":""},{"location":"angular/testing/#1-what-is-karma-in-angular-testing","title":"1. What is Karma in Angular Testing?","text":"<p>Answer: Karma is a test runner for JavaScript that runs tests in real browsers and reports the results. It is the default test runner in Angular projects created using the Angular CLI. Karma allows developers to test the application in different browser environments, providing real-time feedback.</p>"},{"location":"angular/testing/#2-what-is-jasmine-in-angular-testing","title":"2. What is Jasmine in Angular Testing?","text":"<p>Answer: Jasmine is a behavior-driven development (BDD) framework for testing JavaScript code. It provides functions for writing test cases, assertions, and defining test suites using a syntax that is easy to read and understand.</p>"},{"location":"angular/testing/#3-what-is-the-difference-between-karma-and-jasmine","title":"3. What is the Difference Between Karma and Jasmine?","text":"Feature Karma Jasmine Purpose Test runner that executes tests in browsers. Testing framework that defines test cases. Integration Works with different testing frameworks. Works independently or with Karma. Usage Runs and reports test results. Writes and manages test cases."},{"location":"angular/testing/#4-how-do-you-set-up-testing-in-an-angular-project","title":"4. How Do You Set Up Testing in an Angular Project?","text":"<p>Answer: Testing is set up by default in Angular projects created using the Angular CLI. The default setup includes: 1. Karma as the test runner. 2. Jasmine as the testing framework.</p> <p>To run tests, use the command: <pre><code>ng test\n</code></pre></p>"},{"location":"angular/testing/#5-what-are-jasmines-key-functions","title":"5. What are Jasmine's Key Functions?","text":"Function Description Example <code>describe()</code> Defines a test suite (group of related tests). <code>describe('AppComponent', () =&gt; {...})</code> <code>it()</code> Defines an individual test case. <code>it('should create the app', () =&gt; {...})</code> <code>expect()</code> Defines an expectation (assertion) for the test. <code>expect(component.title).toBe('App')</code> <code>beforeEach()</code> Runs setup code before each test case in the suite. <code>beforeEach(() =&gt; {...})</code> <code>afterEach()</code> Runs cleanup code after each test case in the suite. <code>afterEach(() =&gt; {...})</code>"},{"location":"angular/testing/#6-how-do-you-test-a-component-in-angular","title":"6. How Do You Test a Component in Angular?","text":"<p>Answer</p> <p>To test a component, follow these steps:</p> <ol> <li> <p>Import the required modules: <pre><code>import { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { AppComponent } from './app.component';\n</code></pre></p> </li> <li> <p>Create a test suite: <pre><code>describe('AppComponent', () =&gt; {...});\n</code></pre></p> </li> <li> <p>Set up the testing environment using TestBed: <pre><code>beforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [AppComponent]\n  }).compileComponents();\n});\n</code></pre></p> </li> <li> <p>Write test cases using <code>it()</code> and <code>expect()</code>.</p> </li> </ol>"},{"location":"angular/testing/#7-how-do-you-test-a-service-in-angular","title":"7. How Do You Test a Service in Angular?","text":"<p>Answer</p> <p>To test a service, follow these steps:</p> <ol> <li> <p>Import the service and required testing modules: <pre><code>import { TestBed } from '@angular/core/testing';\nimport { DataService } from './data.service';\n</code></pre></p> </li> <li> <p>Create a test suite: <pre><code>describe('DataService', () =&gt; {...});\n</code></pre></p> </li> <li> <p>Inject the service and write test cases: <pre><code>it('should fetch data', () =&gt; {\n  const service: DataService = TestBed.inject(DataService);\n  expect(service.getData()).toEqual(expectedData);\n});\n</code></pre></p> </li> </ol>"},{"location":"angular/testing/#8-what-is-testbed-in-angular-testing","title":"8. What is TestBed in Angular Testing?","text":"<p>Answer</p> <p>TestBed is the primary Angular testing utility that allows you to configure and initialize the environment for unit tests. It provides methods to:</p> <ul> <li>Configure the testing module using <code>TestBed.configureTestingModule()</code>.</li> <li>Create components, services, and inject dependencies for testing.</li> </ul>"},{"location":"angular/testing/#9-what-are-spies-in-jasmine","title":"9. What are Spies in Jasmine?","text":"<p>Answer</p> <p>A spy in Jasmine is a function that tracks how and when it was called. It is used to mock methods and test whether they were called correctly.</p> <p>Example: <pre><code>spyOn(service, 'getData').and.returnValue(mockData);\nexpect(service.getData).toHaveBeenCalled();\n</code></pre></p>"},{"location":"angular/testing/#10-how-do-you-test-asynchronous-code-in-angular","title":"10. How Do You Test Asynchronous Code in Angular?","text":"<p>Answer</p> <p>To test asynchronous code, use Angular's <code>async</code> or <code>fakeAsync</code> utilities:</p> <ul> <li><code>async</code>: Waits for asynchronous tasks (like Promises) to complete before proceeding.</li> <li><code>fakeAsync</code>: Simulates synchronous behavior for asynchronous code using <code>tick()</code>.</li> </ul>"},{"location":"angular/testing/#real-world-scenarios-for-angular-testing","title":"Real-World Scenarios for Angular Testing","text":"Scenario Test Case Tool Form Validation Test if a form is valid or invalid based on user input. Jasmine + Karma API Service Test if an API call returns the expected data and handles errors. Jasmine + HTTP Testing Module User Interaction Test if a button click triggers the correct method in the component. Jasmine + TestBed Directive Behavior Test if a custom directive modifies the DOM as expected. Jasmine + TestBed <p>Summary Karma is a test runner that executes tests in real browsers. Jasmine is a BDD testing framework for writing test cases and assertions. TestBed is used to configure the testing environment for Angular components and services. Use spies and mock services to test method calls and asynchronous code. !!! tip \"Best Practice\" Always write unit tests for critical components, services, and directives to ensure the reliability and maintainability of your Angular application.</p>"},{"location":"best-practices/accesibility/","title":"Web Accessibility Principles","text":"What is Web Accessibility?  **Web Accessibility** refers to the practice of making websites usable by people of all abilities and disabilities. This includes ensuring that users with visual, auditory, motor, or cognitive impairments can access and interact with your website effectively.  Key goals of accessibility: - Ensuring content is perceivable, operable, understandable, and robust. - Creating inclusive websites that are easy to navigate for all users. - Adhering to guidelines and best practices to improve usability for people with disabilities.   Why is Web Accessibility Important?  **Web Accessibility** is important because: - **Legal Compliance**: Many countries have laws requiring websites to be accessible (e.g., ADA in the US, WCAG in Europe). - **Reach a Broader Audience**: By making your site accessible, you help users with disabilities, thereby broadening your audience. - **Improved User Experience**: Accessibility improvements often enhance the overall user experience, making the website easier to use for everyone. - **SEO Benefits**: Search engines like Google prefer accessible sites since they are easier for search engine crawlers to navigate.   What are the WCAG Guidelines?  **WCAG (Web Content Accessibility Guidelines)** are a set of recommendations developed to make web content more accessible. These guidelines are organized into four principles:  1. **Perceivable**: Information and user interface components must be presented in ways that users can perceive (e.g., using text alternatives for non-text content). 2. **Operable**: User interface components and navigation must be operable by users, including those with motor impairments (e.g., keyboard accessibility). 3. **Understandable**: Information and operation of the user interface must be understandable (e.g., readable text, clear navigation). 4. **Robust**: Content must be robust enough to work across a wide variety of devices, platforms, and assistive technologies (e.g., using valid HTML and ARIA).   What are Text Alternatives for Non-Text Content?  **Text alternatives** are provided for non-text content (images, videos, audio) so that it can be understood by people who cannot see or hear it.  Examples: - **Alt Text for Images**: Every image should have a descriptive `alt` attribute, so screen readers can describe it to users with visual impairments.  - **Transcripts for Audio and Video**: Providing transcripts for multimedia content helps users who are deaf or hard of hearing.  - **Captions**: Video captions allow users with hearing impairments to understand spoken content.   How to Make Forms Accessible?  Forms need to be accessible to users with disabilities, particularly those using screen readers or keyboard navigation.  Key practices for accessible forms: - **Label Elements**: Use the `` element to associate form controls with descriptive text.  - **Input Field Descriptions**: Ensure that complex form elements have additional descriptions via `aria-describedby`.  - **Keyboard Accessibility**: All form controls should be navigable using the keyboard (e.g., use `tabindex` for custom controls).   What is Keyboard Accessibility?  **Keyboard accessibility** ensures that all interactive elements on a website can be accessed and used without a mouse. This is particularly important for users with motor impairments or those who prefer keyboard navigation.  Best practices: - Ensure that all clickable elements are focusable using the **Tab** key. - Provide clear focus indicators (e.g., `:focus` CSS style) to show which element is currently selected. - Avoid traps in the navigation flow (e.g., when a user cannot navigate past a specific element).   What is ARIA (Accessible Rich Internet Applications)?  **ARIA (Accessible Rich Internet Applications)** is a set of attributes that help make dynamic web content more accessible. These attributes can be added to HTML elements to provide additional information to assistive technologies.  Some common ARIA attributes: - **`aria-label`**: Provides a label for elements that don\u2019t have visible text labels.  - **`aria-live`**: Informs screen readers about updates to dynamic content (e.g., live regions like notifications).  - **`aria-hidden`**: Hides elements from screen readers (used for decorative elements).   How to Ensure Color Accessibility?  Not all users can perceive color the same way. To ensure your website is accessible to users with color blindness or other visual impairments, follow these guidelines:  - **Color Contrast**: Ensure there is sufficient contrast between text and background colors. The WCAG recommends a contrast ratio of at least 4.5:1 for normal text.  - **Avoid Using Color Alone**: Don\u2019t rely solely on color to convey meaning. Use text labels or icons in addition to color.  - **Color Blindness Tools**: Use tools like color contrast checkers or simulators to test the readability of your site for colorblind users.   What is the Role of Accessible Navigation?  **Accessible navigation** ensures users with disabilities can easily find and navigate through your website\u2019s content.  Best practices for accessible navigation: - **Skip Navigation Links**: Provide a \"skip to content\" link to allow keyboard users to bypass repetitive navigation links.  - **Logical Structure**: Use proper HTML structure with headings (H1-H6) to create a logical order.  - **Accessible Menus**: Ensure dropdown and mobile menus are accessible via keyboard and screen readers.   How Does Accessibility Improve SEO?  **Accessibility** and **SEO** are closely related because both focus on improving the user experience. Here\u2019s how improving accessibility can benefit SEO:  - **Improved User Engagement**: An accessible website provides a better user experience, reducing bounce rates and increasing time spent on the site\u2014both are positive ranking factors for search engines.  - **Content Readability**: Using clear, descriptive text and alt tags helps search engines understand your content better, boosting SEO.  - **Mobile Friendliness**: Many accessibility practices overlap with mobile-friendly design, which is an important ranking factor for SEO.  - **Semantic HTML**: Proper use of headings, links, and metadata makes it easier for search engines to index your content.   What Tools Can Help Test Web Accessibility?  There are several tools available to help test and improve website accessibility:  1. **WAVE (Web Accessibility Evaluation Tool)**: A browser extension that helps identify accessibility issues on web pages. 2. **Lighthouse**: An open-source tool built into Chrome DevTools to audit a website\u2019s performance, accessibility, SEO, and more. 3. **axe Accessibility Checker**: A browser extension that automatically checks your website for WCAG compliance. 4. **Color Contrast Analyzer**: Tools that check the color contrast between text and background for WCAG compliance."},{"location":"best-practices/best-practices/","title":"Best Practices","text":"<ul> <li>Write code with solid Principles</li> <li>Follow angular styles guide</li> <li>Add tets to new functionalit</li> <li>Use descriptive variable names</li> <li>use constants for values that do not change</li> <li>Prioritize readibility over cleverness or brevity</li> <li>commits followed by semantic versioning https://semver.org/</li> <li>Consider maintability while writing code</li> <li>Breaking up bigger fucntions into multiple smaller ones (gen rule: 75 lines of code is Big)</li> <li>Break up big components into smaller more manageable ones</li> <li>Minimize complexity</li> <li>Making Accesbility, Testing, Codeing Guidelines</li> <li>Using Design tokens instead of statc css values</li> </ul>"},{"location":"best-practices/best-practices/#apllication-load-times","title":"Apllication load times","text":"<ul> <li>Enable brotic ststic compression for appplications</li> <li>Enable cache busting on each application build, prod build files should in format main.[unique-id].js</li> <li>Lazy load apps as much as possible , which will decrease load time</li> <li>Tree shaking internally dev libraries, try using ng-samurai</li> <li>Consider making load time feels faster using skeleton loading by letting users know ehat is happening on screen</li> <li>Slpit apps if they get too big , remember to build products, not small monoliths</li> </ul>"},{"location":"best-practices/seo/","title":"SEO Principles","text":"What is SEO?  **SEO (Search Engine Optimization)** is the process of optimizing a website to improve its visibility and ranking on search engines like Google, Bing, or Yahoo. The main goal of SEO is to increase organic (non-paid) traffic to a website.  Key components of SEO include: - **On-Page SEO**: Optimizing individual pages for relevant keywords. - **Off-Page SEO**: Building backlinks from other websites. - **Technical SEO**: Ensuring the website is technically optimized for search engines.   Why is SEO important?  SEO is crucial for businesses and websites because: - **Increased Traffic**: Higher rankings lead to more organic traffic. - **Brand Awareness**: Appear on the first page of search results to increase visibility. - **Better User Experience**: SEO involves optimizing site speed, mobile-friendliness, and easy navigation. - **Cost-Effective**: Organic traffic is free compared to paid advertising.   What are Keywords in SEO?  **Keywords** are the words and phrases users type into search engines when looking for information. Optimizing your website with relevant keywords helps search engines understand what your pages are about.  Key types of keywords: - **Short-tail keywords**: Broad, general terms (e.g., \"SEO\"). - **Long-tail keywords**: More specific and longer phrases (e.g., \"best SEO techniques for beginners\"). - **LSI Keywords**: Latent Semantic Indexing keywords related to the main keyword.  **Best Practices**: - Use keywords naturally in titles, headings, and content. - Include them in meta descriptions, alt text, and URLs.   What is On-Page SEO?  **On-Page SEO** refers to the strategies and optimizations that can be made directly within the website\u2019s content and structure.  Key on-page SEO elements: - **Title Tags**: The title of your web page, typically shown in search results and the browser tab. - **Meta Descriptions**: Short descriptions of the page content, visible in search results. - **Header Tags (H1, H2, H3...)**: Help structure the content and include target keywords. - **URL Structure**: Clean, keyword-rich URLs that are easy for users and search engines to understand. - **Content Optimization**: Creating high-quality, relevant content that matches user intent.   What is Off-Page SEO?  **Off-Page SEO** refers to activities that happen outside of your website to improve its ranking, mainly focusing on building **backlinks** (links from other websites).  Key off-page SEO tactics: - **Backlinks**: Links from high-quality, authoritative websites that point to your content. - **Social Media Engagement**: Promoting content on social media platforms can help drive traffic and indirectly impact SEO. - **Guest Blogging**: Writing articles for other websites in exchange for backlinks. - **Influencer Marketing**: Collaborating with influencers in your industry to promote content. - **Brand Mentions**: Citations of your brand or website on other platforms, even without a direct link.   What is Technical SEO?  **Technical SEO** focuses on improving the technical aspects of a website that help search engines crawl and index the site more effectively.  Key technical SEO factors: - **Site Speed**: Faster websites provide a better user experience and rank higher. - **Mobile-Friendliness**: With mobile-first indexing, ensuring your site is mobile-friendly is crucial. - **XML Sitemap**: A file that helps search engines understand the structure of your site. - **SSL Encryption (HTTPS)**: Secure sites are favored by search engines, making HTTPS a ranking factor. - **Structured Data**: Use of schema markup (e.g., JSON-LD) to help search engines better understand your content and display rich snippets.   What are Backlinks and Why are They Important?  **Backlinks** are links from external websites pointing to your site. Search engines view backlinks as a sign of credibility and authority. The more quality backlinks your site has, the higher it is likely to rank.  Key points about backlinks: - **Quality over Quantity**: A few high-quality backlinks from authoritative sites are better than many low-quality ones. - **Anchor Text**: The clickable text of a backlink should be relevant to the page being linked to. - **Avoiding Spammy Links**: Low-quality or spammy backlinks can harm your SEO rather than help.   What is Mobile-First Indexing in SEO?  **Mobile-First Indexing** means that Google predominantly uses the mobile version of your website to rank it in search results. This is because most searches now come from mobile devices.  Key points: - Ensure your website is **responsive** (adjusts to any screen size). - Mobile site speed is crucial; slow mobile sites will rank lower. - The mobile version of the site should contain the same content and structured data as the desktop version.   What is Local SEO?  **Local SEO** is the practice of optimizing your website to rank higher in local search results. This is particularly useful for businesses that have physical locations or serve specific geographic areas.  Key elements of local SEO: - **Google My Business**: Claim and optimize your Google My Business listing. - **NAP Consistency**: Ensure your business\u2019s **Name, Address, and Phone number** (NAP) are consistent across all online platforms. - **Local Keywords**: Use location-based keywords (e.g., \u201cSEO services in New York\u201d). - **Local Reviews**: Encourage customer reviews on Google and other platforms.   What is Content Optimization in SEO?  **Content optimization** involves ensuring that the content on your website is relevant, well-structured, and optimized for both users and search engines.  Best practices for content optimization: - **Keyword Research**: Understand what users are searching for and integrate those keywords naturally. - **Engaging Content**: Provide valuable, informative content that solves the user\u2019s problem or answers their query. - **Content Length**: Longer, detailed content tends to perform better in search rankings. - **Internal Linking**: Link to other relevant pages on your website to help users and search engines discover more content.   What is User Experience (UX) and How Does it Affect SEO?  **User Experience (UX)** refers to how easy and enjoyable it is for users to interact with a website. Google considers UX signals as part of their ranking algorithms.  Factors that influence UX and SEO: - **Page Speed**: Fast-loading pages provide a better experience and reduce bounce rates. - **Mobile Responsiveness**: Websites must be optimized for mobile devices. - **Navigation**: Simple, easy-to-follow website navigation helps both users and search engines. - **Engaging Design**: An aesthetically pleasing and functional design encourages users to spend more time on the site.   What is the Importance of Meta Tags in SEO?  **Meta tags** are snippets of text in the HTML code of a page that provide information about the content of the page to search engines.  Important meta tags for SEO: - **Meta Title**: Specifies the title of the page (appears in search results and browser tab). - **Meta Description**: A short summary of the page content (appears in search results). - **Meta Robots**: Directs search engines on how to index the page (e.g., `noindex` or `nofollow`).   How Does Search Engine Algorithm Work?  Search engine algorithms are complex systems used by search engines to determine the relevance and ranking of web pages for a given query.  Key factors that influence search engine algorithms: - **Relevance**: How well the page answers the user\u2019s query. - **Quality Content**: High-quality, well-researched content tends to rank higher. - **Backlinks**: High-quality backlinks indicate that your content is authoritative. - **User Engagement**: Metrics like click-through rates (CTR), time on page, and bounce rates impact rankings."},{"location":"css/concepts/","title":"RxJS (Reactive Extensions for JavaScript)","text":"<p>RxJS is a library for reactive programming using observables. It simplifies handling asynchronous and event-based programming tasks by providing operators to compose and transform data streams.</p>"},{"location":"css/concepts/#key-concepts-in-rxjs","title":"Key Concepts in RxJS","text":""},{"location":"css/concepts/#1-observable","title":"1. Observable","text":"<p>An Observable is a data producer that emits values over time. It's a stream of events that you can observe and react to.</p>"},{"location":"css/concepts/#2-observer","title":"2. Observer","text":"<p>An Observer is an object that listens to values emitted by the Observable. It defines how to handle the data, errors, and completion of the stream.</p>"},{"location":"css/concepts/#3-subscription","title":"3. Subscription","text":"<p>A Subscription represents the execution of an Observable. You use it to start or stop observing.</p>"},{"location":"css/concepts/#4-operators","title":"4. Operators","text":"<p>Operators are functions that allow you to manipulate streams, such as filtering, mapping, or combining.</p>"},{"location":"css/concepts/#5-subjects","title":"5. Subjects","text":"<p>Subjects are both Observables and Observers. They are multicast, meaning multiple subscribers can receive values.</p>"},{"location":"css/concepts/#basic-example-observable-and-observer","title":"Basic Example: Observable and Observer","text":"<pre><code>import { Observable } from 'rxjs';\n\n// Create an Observable\nconst observable = new Observable((subscriber) =&gt; {\n  subscriber.next('Hello');\n  subscriber.next('RxJS');\n  subscriber.complete();\n});\n\n// Create an Observer\nconst observer = {\n  next: (value: string) =&gt; console.log('Next:', value),\n  error: (err: any) =&gt; console.error('Error:', err),\n  complete: () =&gt; console.log('Completed!'),\n};\n\n// Subscribe to the Observable\nobservable.subscribe(observer);\n</code></pre>"},{"location":"css/concepts/#rxjs-operators-and-real-life-examples","title":"RxJS Operators and Real-Life Examples","text":"<p>RxJS operators help manage and manipulate streams of data effectively. They are categorized based on their functionality. Below is an overview of the main types of operators, real-life analogies, and examples.</p>"},{"location":"css/concepts/#1-creation-operators","title":"1. Creation Operators","text":"<p>These are used to create new Observables.</p> <p>Example: <code>interval</code> Real Life Analogy: A clock ticking every second, emitting the time at regular intervals.</p>"},{"location":"css/concepts/#2-transformation-operators","title":"2. Transformation Operators","text":"<p>These operators transform or modify emitted values.</p> <p>Example: <code>map</code> Real Life Analogy: Converting temperatures from Celsius to Fahrenheit, transforming one data format into another.</p>"},{"location":"css/concepts/#3-filtering-operators","title":"3. Filtering Operators","text":"<p>These operators filter out unwanted data from the stream.</p> <p>Example: <code>filter</code> Real Life Analogy: Filtering a list of ages to keep only those who are adults (18 years or older).</p>"},{"location":"css/concepts/#4-combination-operators","title":"4. Combination Operators","text":"<p>These operators combine multiple Observables into one.</p> <p>Example: <code>merge</code> Real Life Analogy: Merging multiple live news feeds into a single stream for a unified viewing experience.</p>"},{"location":"css/concepts/#5-utility-operators","title":"5. Utility Operators","text":"<p>These operators provide utility functions for Observables, like managing subscriptions.</p> <p>Example: <code>tap</code> Real Life Analogy: Logging data passing through a pipeline for debugging without modifying it.</p>"},{"location":"css/concepts/#6-error-handling-operators","title":"6. Error Handling Operators","text":"<p>These operators help manage and recover from errors.</p> <p>Example: <code>catchError</code> Real Life Analogy: Handling a server error by providing a default fallback response.</p>"},{"location":"css/concepts/#7-multicasting-operators","title":"7. Multicasting Operators","text":"<p>These operators share a single Observable execution among multiple subscribers.</p> <p>Example: <code>share</code> Real Life Analogy: Sharing a live video feed with multiple viewers, where the feed is created only once.</p> <p>RxJS operators allow for powerful manipulation of data streams and make managing complex asynchronous operations more efficient and intuitive.</p>"},{"location":"html/concepts/","title":"HTML5 Interview Questions","text":"What is HTML5? How is it different from HTML4?  HTML5 is the latest version of HTML, designed to improve multimedia handling, semantic markup, and web applications without relying on external plugins (like Flash).  **Differences from HTML4:** - Introduced semantic elements like ``, ``, ``, and ``. - Supports multimedia elements like `` and ``. - Includes new APIs like Web Storage, Canvas, and Geolocation. - Provides better error handling and browser compatibility.   What are some new semantic elements introduced in HTML5?  - ``: Represents the introductory content or navigational links. - ``: Represents footer content like author information, copyright, etc. - ``: Represents self-contained content. - ``: Defines sections in a document. - ``: Represents content tangentially related to the main content. - ``: Represents the main content of a document.   What are HTML5 Web Storage APIs? How are they different from cookies?  HTML5 provides two Web Storage APIs for client-side data storage: - **localStorage**: Stores data with no expiration date. - **sessionStorage**: Stores data for the session (cleared when the browser is closed).  **Differences from Cookies:** - Larger storage capacity (5MB per domain compared to ~4KB for cookies). - Stored only on the client-side, reducing server load. - Faster because it doesn\u2019t send data with every HTTP request.   Explain the purpose of the `` element in HTML5.  The `` element is used for drawing graphics via JavaScript. It allows developers to create: - 2D/3D graphics - Animations - Game graphics  Example: <pre><code>&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;\n&lt;script&gt;\n  const canvas = document.getElementById('myCanvas');\n  const ctx = canvas.getContext('2d');\n  ctx.fillStyle = 'blue';\n  ctx.fillRect(10, 10, 150, 80);\n&lt;/script&gt;\n</code></pre> What is the difference between `` and `` tags in HTML5?  - **``**: Embeds audio content. - **``**: Embeds video content.  Both support attributes like `controls`, `autoplay`, and `loop`. Example: <pre><code>&lt;audio controls&gt;\n  &lt;source src=\"audio.mp3\" type=\"audio/mpeg\"&gt;\n  Your browser does not support the audio element.\n&lt;/audio&gt;\n\n&lt;video controls width=\"400\"&gt;\n  &lt;source src=\"video.mp4\" type=\"video/mp4\"&gt;\n  Your browser does not support the video element.\n&lt;/video&gt;\n</code></pre> What is the purpose of the `` tag in HTML5?  The `` tag is used to provide a list of predefined options for an `` element. It improves user experience by offering suggestions as the user types.  Example: <pre><code>&lt;input list=\"browsers\" name=\"browser\"&gt;\n&lt;datalist id=\"browsers\"&gt;\n  &lt;option value=\"Chrome\"&gt;\n  &lt;option value=\"Firefox\"&gt;\n  &lt;option value=\"Safari\"&gt;\n  &lt;option value=\"Edge\"&gt;\n&lt;/datalist&gt;\n</code></pre> What is the difference between `` and `` tags?  - **``**: Represents the completion progress of a task (e.g., file upload). - **``**: Represents a scalar measurement within a known range (e.g., disk usage).  Examples: <pre><code>&lt;progress value=\"70\" max=\"100\"&gt;&lt;/progress&gt;\n\n&lt;meter value=\"0.6\" min=\"0\" max=\"1\"&gt;&lt;/meter&gt;\n</code></pre> What is the purpose of the HTML5 Geolocation API?  The Geolocation API allows a website to access the user\u2019s location (with their consent). Commonly used in applications like maps and location-based services.  Example: <pre><code>if (navigator.geolocation) {\n  navigator.geolocation.getCurrentPosition((position) =&gt; {\n    console.log(`Latitude: ${position.coords.latitude}`);\n    console.log(`Longitude: ${position.coords.longitude}`);\n  });\n} else {\n  console.log('Geolocation is not supported by this browser.');\n}\n</code></pre> What is the purpose of the `required` attribute in HTML5 forms?  The `required` attribute ensures that the user fills in a field before submitting the form. It enhances form validation without needing JavaScript.  Example: <pre><code>&lt;form&gt;\n  &lt;label for=\"email\"&gt;Email:&lt;/label&gt;\n  &lt;input type=\"email\" id=\"email\" name=\"email\" required&gt;\n  &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> What are custom elements in HTML5?  Custom elements are a feature of the Web Components specification that allows developers to define their own HTML tags with custom behavior.  Key parts: - **Custom element classes**: Define custom HTML elements using JavaScript. - **Shadow DOM**: Encapsulates styles and scripts to avoid conflicts. - **HTML templates**: Provide reusable structures.  Example: <pre><code>class MyElement extends HTMLElement {\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: 'open' });\n    shadow.innerHTML = `&lt;p&gt;Hello from custom element!&lt;/p&gt;`;\n  }\n}\ncustomElements.define('my-element', MyElement);\n</code></pre>  Usage: <pre><code>&lt;my-element&gt;&lt;/my-element&gt;\n</code></pre> How does the `` tag improve image responsiveness?  The `` tag allows developers to define multiple image sources for different screen sizes or resolutions. This improves responsiveness by serving the most appropriate image based on the user\u2019s device or browser.  Example: <pre><code>&lt;picture&gt;\n  &lt;source srcset=\"image-small.jpg\" media=\"(max-width: 600px)\"&gt;\n  &lt;source srcset=\"image-medium.jpg\" media=\"(max-width: 1200px)\"&gt;\n  &lt;img src=\"image-large.jpg\" alt=\"Responsive example\"&gt;\n&lt;/picture&gt;\n</code></pre>  - The browser selects the first `` that matches the media query. - If no `` matches, the `` tag acts as a fallback.   What is the purpose of the `` tag in HTML5?  The `` tag is used to define HTML fragments that are not rendered until they are explicitly added to the DOM via JavaScript. It is commonly used for reusable components.  Example: <pre><code>&lt;template id=\"my-template\"&gt;\n  &lt;div class=\"template-content\"&gt;\n    &lt;p&gt;This content will be rendered dynamically.&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  const template = document.getElementById('my-template');\n  const content = template.content.cloneNode(true);\n  document.body.appendChild(content);\n&lt;/script&gt;\n</code></pre> What is the purpose of the `` tag in HTML5?  The `` tag is used to highlight text, typically to indicate relevance or a match in search results.  Example: <pre><code>&lt;p&gt;The &lt;mark&gt;highlighted text&lt;/mark&gt; is important.&lt;/p&gt;\n</code></pre> What are some common global attributes in HTML5?  Global attributes can be used on any HTML element. Examples include: - `class`: Assigns one or more class names. - `id`: Assigns a unique identifier. - `style`: Inline CSS styles. - `title`: Specifies extra information displayed as a tooltip. - `data-*`: Custom data attributes for embedding data.  Example: <pre><code>&lt;div id=\"unique\" class=\"example\" data-info=\"custom-data\"&gt;Example content&lt;/div&gt;\n</code></pre>"},{"location":"js/concepts/","title":"concepts","text":""},{"location":"js/concepts/#basics","title":"Basics","text":"<p>About</p> <p>JavaScript is a dynamic, interpreted programming language that runs in the browser or on a server (Node.js). It is single-threaded, meaning that it can only execute one operation at a time. However, JavaScript uses certain concepts such as execution context, call stack, and hoisting to handle various operations in a way that provides asynchronous behavior and manages multiple tasks.</p> Concept Explanation Examples Execution Context Holds information about the environment in which the current code is executed. Defines the scope, variable values, and function executions. - Global Execution Context: Default context for global code execution.  - Function Execution Context: Created when a function is invoked.  - Eval Execution Context: Rarely used, when code is executed inside an <code>eval()</code>. Components of Execution Context Contains:  - Variable Environment: Holds variables, functions, and parameters.  - Lexical Environment: Contains variables declared in the current scope.  - This Binding: Refers to the object executing the current code. Variable Environment Refers to where variables and functions are stored during code execution, managing scope and access. - Local Variables: Variables declared inside a function.  - Function Parameters: Arguments passed into a function.  - Function Declarations: Functions in the current scope. Call Stack A stack data structure used to track function calls. When a function is invoked, its execution context is pushed onto the stack. Once the function execution completes, the context is popped off. - The Call Stack keeps track of the order of function execution.  Example: <code>function a() { b(); } function b() { console.log('Hello'); }</code> Call stack: <code>a()</code> \u2192 <code>b()</code>. Event Loop The event loop constantly checks the call stack and callback queue. If the call stack is empty, it pushes the first callback from the callback queue to the call stack for execution. - The Event Loop allows asynchronous code (like <code>setTimeout</code> or promises) to be executed once the call stack is clear.  Example: <code>setTimeout(() =&gt; { console.log('Done'); }, 1000);</code> Garbage Collector A mechanism that automatically frees up memory by cleaning up unused objects that are no longer referenced. The garbage collector works in the background without direct developer intervention. - The Garbage Collector runs periodically to identify and remove objects that are no longer needed or referenced.  Example: <code>let obj = { name: 'Test' }; obj = null;</code> (The object is now eligible for garbage collection). Example (Thread Execution) When a function is called, it is pushed onto the call stack. Asynchronous code moves callbacks to the event loop's callback queue. When the stack is empty, the event loop executes them. <code>function example() { let x = 10; console.log(x); } example();</code> <code>x</code> is stored in the function\u2019s execution context. <p>### ES5 features</p> Version Feature Description Example ES5 Strict Mode Introduced strict mode to catch common coding errors and improve performance. <code>'use strict'; &lt;br&gt; var x = 10; &lt;br&gt; delete x; // Error</code> Array Methods New methods like <code>forEach()</code>, <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, and <code>some()</code> to simplify array operations. <code>arr.forEach(item =&gt; console.log(item)); &lt;br&gt; arr.map(x =&gt; x * 2);</code> JSON The <code>JSON</code> object was introduced to parse and stringify JSON data. <code>JSON.parse('{\"name\": \"John\"}'); &lt;br&gt; JSON.stringify({name: \"John\"});</code> Object Methods Added <code>Object.create()</code>, <code>Object.defineProperty()</code>, <code>Object.defineProperties()</code>, <code>Object.getOwnPropertyNames()</code>. <code>Object.create(null); &lt;br&gt; Object.defineProperty(obj, 'prop', { value: 42 });</code> ES6 Arrow Functions Introduced a shorter syntax for functions and lexical <code>this</code> binding. <code>const sum = (a, b) =&gt; a + b;</code> Let and Const Introduced block-scoped variables (<code>let</code>) and constants (<code>const</code>). <code>let x = 10; &lt;br&gt; const y = 20;</code> Template Literals String interpolation with backticks and expression embedding. <code>let str = `Hello, ${name}`</code> Destructuring Assignment Assign variables from arrays or objects in a concise way. <code>const [a, b] = [1, 2]; &lt;br&gt; const {x, y} = obj;</code> Default Parameters Parameters can have default values. <code>function greet(name = 'Guest') { console.log(name); }</code> Promises Native support for promises to handle asynchronous operations. <code>new Promise((resolve, reject) =&gt; { resolve('Done'); }).then(data =&gt; console.log(data));</code> Classes Introduced class syntax for object-oriented programming. <code>class Person { constructor(name) { this.name = name; } }</code> Modules Introduced the <code>import</code> and <code>export</code> statements to support modular code. <code>import { add } from './math.js'; &lt;br&gt; export function add(a, b) { return a + b; }</code> ES7 Array.prototype.includes() Added <code>includes()</code> to check if an element exists in an array. <code>[1, 2, 3].includes(2); // true</code> Exponentiation Operator Introduced the exponentiation operator (<code>**</code>) for raising a number to a power. <code>2 ** 3; // 8</code> ES8 Async/Await Introduced async functions and the <code>await</code> keyword for handling promises more intuitively. <code>async function fetchData() { let result = await fetch('url'); return result.json(); }</code> Object.values() / Object.entries() Methods to return an array of values or an array of key-value pairs from an object. <code>Object.values({a: 1, b: 2}); // [1, 2]</code> <code>Object.entries({a: 1, b: 2}); // [['a', 1], ['b', 2]]</code> String padding Added <code>padStart()</code> and <code>padEnd()</code> to pad a string to a specified length. <code>'5'.padStart(3, '0'); // '005' &lt;br&gt; '5'.padEnd(3, '0'); // '500'</code> ES9 Asynchronous Iteration Introduced <code>for-await-of</code> for iterating over asynchronous data sources like promises. <code>async function printData() { for await (let data of fetchData()) { console.log(data); } }</code> Object Rest and Spread Properties Spread and rest properties were added for objects, enabling easier copying and merging of objects. <code>const obj = { ...sourceObj }; &lt;br&gt; const { a, b, ...rest } = obj;</code> ES10 Array.prototype.flat() Introduced <code>flat()</code> to flatten nested arrays into a single array. <code>[1, [2, [3]]].flat(2); // [1, 2, 3]</code> String.prototype.trimStart() / trimEnd() Methods to trim whitespace from the beginning or end of a string. <code>'  hello  '.trimStart(); // 'hello  ' &lt;br&gt; '  hello  '.trimEnd(); // '  hello'</code> Optional Catch Binding Allows <code>catch</code> to omit the error parameter if not needed. <code>try { throw new Error(); } catch { console.log('Error caught'); }</code> ES11 Nullish Coalescing Operator (??) Introduced the nullish coalescing operator to return the right-hand operand only when the left-hand is <code>null</code> or <code>undefined</code>. <code>let result = a ?? b; // Returns b if a is null or undefined</code> Optional Chaining (?.) Allows safe access to nested properties without throwing errors when a property is <code>null</code> or <code>undefined</code>. <code>let name = person?.address?.street; // Returns undefined if any part is null or undefined</code> BigInt Added support for large integers beyond the <code>Number</code> type. <code>let bigInt = 1234567890123456789012345678901234567890n;</code> Promise.allSettled() Returns a promise that resolves after all input promises have settled (either resolved or rejected). <code>Promise.allSettled([p1, p2]).then(results =&gt; console.log(results));</code> ES12 Logical Assignment Operators Combines logical operators (<code>&amp;&amp;</code>, <code>||</code>, <code>??</code>) with assignment. <code>x &amp;&amp;= y; &lt;br&gt; x ||= y; &lt;br&gt; x ??= y;</code> WeakRefs Introduced <code>WeakRef</code> and <code>FinalizationRegistry</code> for weak references, allowing objects to be garbage collected. <code>let ref = new WeakRef(obj);</code> Numeric Separators Introduced underscores as separators in numeric literals for better readability. <code>let num = 1_000_000; // 1000000</code> ES13 (Future) Top-level Await Allows <code>await</code> to be used at the top level in modules, without needing to wrap it inside an <code>async</code> function. <code>// In an ES module file &lt;br&gt; await fetch('data.json');</code> Logical Nullish Assignment (??=) Simplifies nullish coalescing assignment (combines <code>??</code> with <code>=</code>). <code>x ??= y; // Assign y only if x is null or undefined</code> Future Pattern Matching (proposal) Pattern matching (similar to switch statements) to match against complex patterns in JavaScript. <code>match (value) { case 1: return \"One\"; case [a, b]: return \"Pair\"; }</code> <p>Key Features 1. Dynamic Typing: Types are determined at runtime. 2. Prototypal Inheritance: Objects inherit directly from other objects. 3. Event-Driven: Used to handle events like user actions or server responses. 4. Asynchronous Programming: Supports asynchronous operations with <code>callbacks</code>, <code>promises</code>, and <code>async/await</code>. 5. Cross-Platform: Runs on all major browsers and environments like Node.js.</p> <p>JS execution</p> <p>Everything happens in Execution context. it consits of two components</p> <pre><code>1. memory component -&gt; Variable Envimronment  - JS first stores the variables(undefined) and fucntion declarations(f{...}).\n\n2. code component   -&gt; Thread Execution -&gt; synchronous single threaded language which make executes the code line by line like assigning values to function execution.\n</code></pre> <p>call stack: for every a new execution stack will be creaetd and handled on top of GEC as E1, E2 once return it will remove the execution context from memory</p> <p>Hoisting: var and function declation can be accessed even before initialization becase of its defined in variable env and var as undefined and function as whole. vavr and functions will be moved to tope of its scope</p> <p><pre><code>var a = 1,\nb();\nc();\nconsole.log(a);\nb(){a=10; console.log(a)};\nc(){a=100; console.log(a)};\noutput: 10\n       100\n       1\n</code></pre>    Every JS program will have a responsibility of creating of an Global object. for chromw v8engine-&gt; window</p> <p>Data types</p> <ul> <li>Primitive Types: <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Undefined</code>, <code>Null</code>, <code>BigInt</code>, <code>Symbol</code>.</li> <li>Non-Primitive Types: Objects (including arrays, functions, and objects).</li> </ul> control statements   # Control Flow Statements in JavaScript  Control flow statements in JavaScript allow you to control the execution flow of your program based on certain conditions. These statements enable decision-making, looping, and error handling. Below are the primary types of control flow statements in JavaScript:  ## 1. Conditional Statements  Conditional statements are used to perform different actions based on different conditions.   `if` Statement The `if` statement executes a block of code if the condition evaluates to `true`.      <pre><code>if (condition) {\n  // Code to execute if the condition is true\n}\n</code></pre>   `if...else` Statement The `if...else` statement provides an alternative set of instructions to execute if the condition is `false`.      <pre><code>if (condition) {\n  // Code to execute if the condition is true\n} else {\n  // Code to execute if the condition is false\n}\n</code></pre>   `if...else if...else` Statement This structure allows you to check multiple conditions. If the first condition is `false`, it checks the second one, and so on.      <pre><code>if (condition1) {\n  // Code to execute if condition1 is true\n} else if (condition2) {\n  // Code to execute if condition2 is true\n} else {\n  // Code to execute if all conditions are false\n}\n</code></pre>   `switch` Statement The `switch` statement evaluates an expression and executes the corresponding block of code based on the matching `case`. It's useful when you have many possible conditions for one variable or expression.      <pre><code>switch (expression) {\n  case value1:\n    // Code to execute if expression equals value1\n    break;\n  case value2:\n    // Code to execute if expression equals value2\n    break;\n  default:\n    // Code to execute if no case matches\n}\n</code></pre>   2. Looping Statements  Looping statements are used to execute a block of code repeatedly.   `for` Loop The `for` loop is used when you know beforehand how many times you want to execute a statement or a block of code.      <pre><code>for (let i = 0; i &lt; 5; i++) {\n  console.log(i); // Prints numbers 0 to 4\n}\n</code></pre>   `while` Loop The `while` loop executes a block of code as long as the specified condition evaluates to `true`.      <pre><code>let i = 0;\nwhile (i &lt; 5) {\n  console.log(i); // Prints numbers 0 to 4\n  i++;\n}\n</code></pre>   `do...while` Loop The `do...while` loop is similar to the `while` loop, except that it guarantees the block of code will execute at least once, even if the condition is false at the beginning.      <pre><code>let i = 0;\ndo {\n  console.log(i); // Prints numbers 0 to 4\n  i++;\n} while (i &lt; 5);\n</code></pre>  ### `for...in` Loop The `for...in` loop is used to iterate over the enumerable properties of an object. It\u2019s ideal for looping through object properties or array indexes.      <pre><code>let person = { name: 'John', age: 30, city: 'New York' };\nfor (let key in person) {\n  console.log(key, person[key]); // Prints key-value pairs\n}\n</code></pre>   `for...of` Loop The `for...of` loop is used to iterate over iterable objects like arrays, strings, and other iterable collections. It is preferred when you need to loop through values, not keys or indexes.      <pre><code>let arr = [10, 20, 30];\nfor (let value of arr) {\n  console.log(value); // Prints values 10, 20, 30\n}\n</code></pre>  ## 3. Break and Continue   `break` Statement The `break` statement is used to exit a loop or `switch` statement before its normal termination.      <pre><code>for (let i = 0; i &lt; 10; i++) {\n  if (i === 5) {\n    break; // Exit loop when i is 5\n  }\n  console.log(i); // Prints numbers 0 to 4\n}\n</code></pre>   `continue` Statement The `continue` statement is used to skip the current iteration of a loop and continue with the next iteration.      <pre><code>for (let i = 0; i &lt; 5; i++) {\n  if (i === 3) {\n    continue; // Skip when i is 3\n  }\n  console.log(i); // Prints numbers 0, 1, 2, 4\n}\n</code></pre>   4. Error Handling Statements  ### `try...catch` Statement The `try...catch` statement allows you to test a block of code for errors and handle the error if one occurs.      <pre><code>try {\n  let result = riskyOperation();\n} catch (error) {\n  console.log('An error occurred:', error.message);\n}\n</code></pre>   `finally` Block The `finally` block executes code after `try...catch`, regardless of whether an error occurred or not. It is often used for cleanup tasks.      <pre><code>try {\n  let result = riskyOperation();\n} catch (error) {\n  console.log('An error occurred:', error.message);\n} finally {\n  console.log('This block will run regardless of success or failure');\n}\n</code></pre>   5. Ternary (Conditional) Operator The ternary operator is a shorthand for `if...else` statements. It evaluates a condition and returns one of two values depending on whether the condition is true or false.      <pre><code>let age = 20;\nlet canVote = (age &gt;= 18) ? 'Yes' : 'No';\nconsole.log(canVote); // Prints 'Yes'\n</code></pre>  ---  This structure ensures the flow remains intact without any interruptions due to code blocks. Let me know if you need further adjustments!   <p>type co-ersion, Nan</p> <p>Implicit type coercion in javascript is the automatic conversion of value from one data type to another. </p> <p>It takes place when the operands of an expression are of different data types.</p> <p>NaN property represents the \u201cNot-a-Number\u201d value. It indicates a value that is not a legal number. </p> <p>Pass by value &amp; pass by reference</p> <p>For primitive data types when passed to another variable, are passed by value. A new space of memory for the copied value  is created.   For Non- primitive data types    directly passes the location of the variable obj to the variable obj2.    In other words, the reference of the variable obj is passed to the variable obj2.</p> <pre><code>```typescript\ndeep copyig of an object\nconst obj1 = { a: 1 };\nconst obj2 = { b: 2 };\n\nconst newObj = Object.assign({}, obj1, obj2);\n\nconsole.log(newObj);\n// { a: 1, b: 2 }\nJSON.parse(JSON.stringify(obj1));\nconst newObj = { ...obj1, ...obj2 };\n```\n</code></pre> Prototype, Scope, Scope Chaining, and Inheritance in JavaScript    In JavaScript, concepts like **prototypes**, **scope**, **scope chaining**, and **inheritance** are fundamental to understanding how the language works. These concepts dictate how properties, methods, and variables are accessed and inherited across objects and functions.    **Prototype**: JavaScript uses **prototype-based inheritance**. Every JavaScript object has a prototype, which is another object from which it inherits properties and methods. The prototype chain allows you to access properties and methods that are not directly present on the object itself but are defined on its prototype.    **Prototype Example**:      <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log('Hello, ' + this.name);\n};\n\nconst john = new Person('John', 25);\njohn.sayHello(); // Output: Hello, John\n</code></pre>    In this example:   - The `Person` constructor function creates objects with the properties `name` and `age`.   - The `sayHello` method is added to `Person`'s prototype, meaning all instances of `Person` can access it, even though it's not directly defined on the instance itself.   - When `john.sayHello()` is called, JavaScript looks for `sayHello` on `john`, but since it's not found, it checks `john`'s prototype.    **Scope**: In JavaScript, **scope** refers to the context in which a variable is declared and accessible. There are two main types of scope:   - **Global Scope**: Variables declared outside of any function are in the global scope and can be accessed from anywhere in the program.   - **Function Scope**: Variables declared inside a function are only accessible within that function.    **Scope Example**:      <pre><code>let globalVar = 'I am global';\n\nfunction checkScope() {\n  let localVar = 'I am local';\n  console.log(globalVar); // I am global\n  console.log(localVar); // I am local\n}\n\ncheckScope();\nconsole.log(globalVar); // I am global\n// console.log(localVar); // Error: localVar is not defined\n</code></pre>    In this example, `globalVar` is accessible both inside and outside the function, while `localVar` is only accessible inside the `checkScope` function.    **Scope Chaining**: JavaScript uses **scope chaining** to resolve variable references. If a variable is not found in the current scope, JavaScript looks up the chain of scopes until it either finds the variable or reaches the global scope. If the variable is not found in the global scope, an error is thrown.    **Scope Chaining Example**:      <pre><code>let globalVar = 'I am global';\n\nfunction outerFunction() {\n  let outerVar = 'I am outer';\n\n  function innerFunction() {\n    let innerVar = 'I am inner';\n    console.log(globalVar); // I am global\n    console.log(outerVar); // I am outer\n    console.log(innerVar); // I am inner\n  }\n\n  innerFunction();\n}\n\nouterFunction();\n</code></pre>    In this example, `innerFunction` has access to variables defined in both `outerFunction` and the global scope, demonstrating scope chaining.    **Inheritance**: JavaScript uses **prototype-based inheritance** rather than classical inheritance. Objects can inherit properties and methods from other objects through their prototype chain.    **Inheritance Example**:      <pre><code>function Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.sayHello = function() {\n  console.log('Hello, I am ' + this.name);\n};\n\nfunction Dog(name) {\n  Animal.call(this, name); // Inherit properties from Animal\n}\n\nDog.prototype = Object.create(Animal.prototype); // Inherit methods from Animal\nDog.prototype.constructor = Dog;\n\nconst dog = new Dog('Buddy');\ndog.sayHello(); // Output: Hello, I am Buddy\n</code></pre>    In this example:   - `Dog` inherits from `Animal` using `Object.create(Animal.prototype)`.   - The `call` method is used to inherit properties from `Animal` within the `Dog` constructor function.   - `Dog` instances can now call `sayHello`, which was defined on the `Animal` prototype.   Event Bubbling and Event Capturing   # Event Bubbling and Event Capturing in JavaScript  Event bubbling and event capturing are two phases of event propagation in the DOM (Document Object Model). When an event is triggered, it propagates through the DOM either from the target element to the root (bubbling) or from the root to the target element (capturing). These phases determine the order in which event listeners are called.   1. Event Bubbling  In event bubbling, the event starts from the target element and bubbles up to the root element. It means that the innermost event listener is triggered first, and the event bubbles up to outer elements.   Event Bubbling Example      <pre><code>// HTML\n&lt;div id=\"parent\"&gt;\n  &lt;button id=\"child\"&gt;Click me&lt;/button&gt;\n&lt;/div&gt;\n\n// JavaScript\ndocument.getElementById('parent').addEventListener('click', function() {\n  alert('Parent clicked');\n});\n\ndocument.getElementById('child').addEventListener('click', function() {\n  alert('Child clicked');\n});\n</code></pre>  In this example: 1. When you click the **child button**, the event will first trigger the **child's** event listener. 2. After that, the event will bubble up and trigger the **parent's** event listener.   Stopping Event Bubbling You can stop event bubbling by calling the `stopPropagation()` method within the event handler.      <pre><code>document.getElementById('child').addEventListener('click', function(event) {\n  alert('Child clicked');\n  event.stopPropagation(); // Stops the event from bubbling up\n});\n</code></pre>   2. Event Capturing (Trickling)  In event capturing (or trickling), the event starts from the root element and trickles down to the target element. This is the opposite of event bubbling. The outermost event listener is triggered first, and the event then propagates down to the target element.   Event Capturing Example  To enable capturing, you need to pass an additional `true` value as the third argument to `addEventListener`.      <pre><code>// HTML\n&lt;div id=\"parent\"&gt;\n  &lt;button id=\"child\"&gt;Click me&lt;/button&gt;\n&lt;/div&gt;\n\n// JavaScript\ndocument.getElementById('parent').addEventListener('click', function() {\n  alert('Parent clicked (capturing phase)');\n}, true);\n\ndocument.getElementById('child').addEventListener('click', function() {\n  alert('Child clicked');\n});\n</code></pre>  In this example: 1. When you click the **child button**, the event will first trigger the **parent's** event listener in the capturing phase. 2. After that, it will trigger the **child's** event listener.   Stopping Event Capturing You can also stop event capturing by using the `stopPropagation()` method within the event handler.      <pre><code>document.getElementById('parent').addEventListener('click', function(event) {\n  alert('Parent clicked');\n  event.stopPropagation(); // Stops the event from propagating further\n}, true);\n</code></pre>  ## 3. Methods Related to Event Bubbling and Capturing  JavaScript provides several methods that are useful in managing event propagation during the bubbling and capturing phases.  ### `stopPropagation()` This method stops the event from bubbling up or trickling down the DOM tree. It can be used in both event bubbling and capturing phases.      <pre><code>element.addEventListener('click', function(event) {\n  event.stopPropagation();\n});\n</code></pre>   `stopImmediatePropagation()` This method not only stops the event from propagating but also prevents other listeners on the same element from being called.      <pre><code>element.addEventListener('click', function(event) {\n  event.stopImmediatePropagation();\n});\n</code></pre>   `preventDefault()` This method prevents the default behavior of the event. It's commonly used for actions like form submission or link navigation.      <pre><code>link.addEventListener('click', function(event) {\n  event.preventDefault(); // Prevents the link from navigating\n});\n</code></pre>   4. Event Listeners in Different Phases  By default, event listeners are added in the **bubbling phase**. However, you can specify whether an event listener should be triggered in the capturing phase by passing `true` as the third argument to `addEventListener`.   Bubbling Phase (Default)     <pre><code>element.addEventListener('click', function() {\n  console.log('Event in bubbling phase');\n});\n</code></pre>   Capturing Phase     <pre><code>element.addEventListener('click', function() {\n  console.log('Event in capturing phase');\n}, true);  // `true` enables capturing phase\n</code></pre>  ---  This structure helps explain both event bubbling and capturing clearly while keeping the flow intact."},{"location":"js/concepts/#functions","title":"Functions","text":"JavaScript Functions <p>Higher-Order Functions</p> <p>     A higher-order function is a function that can take other functions as arguments or return a function as its result. This allows you to compose functions and create more reusable and flexible code.   </p> <pre>\n    <pre><code>function mapArray(arr, fn) {\n  return arr.map(fn);\n}\nconst result = mapArray([1, 2, 3], x =&gt; x * 2);\nconsole.log(result); // [2, 4, 6]\n</code></pre>\n  </pre> <p>Anonymous Functions</p> <p>     Anonymous functions are functions that do not have a name. They are often used as arguments to higher-order functions or assigned to variables for one-time use.   </p> <pre>\n    <pre><code>setTimeout(function() {\n  console.log('Hello, World!');\n}, 1000);\n</code></pre>\n  </pre> <p>Closures</p> <p>     A closure is a function that retains access to its lexical environment, even after the outer function has returned. This allows it to remember variables from the scope in which it was created.   </p> <pre>\n    <pre><code>function outer() {\n  let count = 0;\n  return function inner() {\n    count++;\n    console.log(count);\n  };\n}\nlet counter = outer();\ncounter(); // 1\ncounter(); // 2\n</code></pre>\n  </pre> <p>Immediately Invoked Function Expression (IIFE)</p> <p>     An IIFE is a function expression that is invoked immediately after its definition. It is often used to create a new scope and avoid polluting the global namespace.   </p> <pre>\n    <pre><code>(function() {\n  let message = 'Hello, World!';\n  console.log(message);\n})();\n</code></pre>\n  </pre> <p>call() Method</p> <p>     The `call()` method invokes a function with a specified `this` value and individual arguments. It is commonly used to set the context of a function.   </p> <pre>\n    <pre><code>function greet(name) {\n  console.log(`Hello, ${name}`);\n}\ngreet.call(null, 'John'); // Hello, John\n</code></pre>\n  </pre> <p>apply() Method</p> <p>     The `apply()` method is similar to `call()`, but it takes the arguments as an array. It's useful when you want to pass a list of arguments to a function.   </p> <pre>\n    <pre><code>function greet(name, age) {\n  console.log(`${name} is ${age} years old.`);\n}\ngreet.apply(null, ['Alice', 25]); // Alice is 25 years old.\n</code></pre>\n  </pre> <p>bind() Method</p> <p>     The `bind()` method creates a new function with a specified `this` value and initial arguments, which can then be invoked later.   </p> <pre>\n    <pre><code>function greet(name) {\n  console.log(`Hello, ${name}`);\n}\nconst greetJohn = greet.bind(null, 'John');\ngreetJohn(); // Hello, John\n</code></pre>\n  </pre> <p>exec() Method</p> <p>     The `exec()` method is used with regular expressions to execute a search for a match in a string. It returns an array of matched results or `null` if no match is found.   </p> <pre>\n    <pre><code>const regex = /hello/;\nconst result = regex.exec('hello world');\nconsole.log(result); // ['hello']\n</code></pre>\n  </pre> <p>test() Method</p> <p>     The `test()` method is used to test whether a pattern exists in a string, returning `true` or `false` based on the result.   </p> <pre>\n    <pre><code>const regex = /world/;\nconst result = regex.test('hello world');\nconsole.log(result); // true\n</code></pre>\n  </pre> <p>Currying</p> <p>     Currying is a technique where a function is transformed into a sequence of functions that each take one argument and return a new function. It allows partial application of functions.   </p> <pre>\n    <pre><code>function add(a) {\n  return function(b) {\n    return a + b;\n  };\n}\nconst add5 = add(5);\nconsole.log(add5(10)); // 15\n</code></pre>\n  </pre> <p>Callback Functions</p> <p>     A callback function is a function that is passed into another function as an argument, to be executed later.   </p> <pre>\n    <pre><code>function fetchData(callback) {\n  setTimeout(() =&gt; {\n    callback('Data fetched');\n  }, 1000);\n}\nfetchData(message =&gt; console.log(message)); // Data fetched\n</code></pre>\n  </pre> <p>Recursion</p> <p>     Recursion is when a function calls itself in order to solve a problem. It often involves a base case to stop the recursion and prevent an infinite loop.   </p> <pre>\n    <pre><code>function factorial(n) {\n  if (n &lt;= 1) return 1;\n  return n * factorial(n - 1);\n}\nconsole.log(factorial(5)); // 120\n</code></pre>\n  </pre> <p>Arrow Functions</p> <p>     Arrow functions provide a shorter syntax for writing functions. They also do not bind their own `this`, instead they inherit it from the enclosing scope.   </p> <pre>\n    <pre><code>const add = (a, b) =&gt; a + b;\nconsole.log(add(2, 3)); // 5\n</code></pre>\n  </pre> <p>Rest and Spread Operators</p> <p>     The rest operator (`...`) allows you to collect multiple arguments into an array. The spread operator (`...`) allows you to expand an array or object into individual elements.   </p> <pre>\n    <pre><code>// Rest\nfunction sum(...numbers) {\n  return numbers.reduce((a, b) =&gt; a + b, 0);\n}\nconsole.log(sum(1, 2, 3)); // 6\n\n// Spread\nconst arr1 = [1, 2, 3];\nconst arr2 = [...arr1, 4, 5];\nconsole.log(arr2); // [1, 2, 3, 4, 5]\n</code></pre>\n  </pre> <p>Shallow Copy vs Deep Copy</p> <p>     A shallow copy copies the top-level properties of an object, whereas a deep copy duplicates the entire structure, including nested objects.   </p> <pre>\n    <pre><code>// Shallow Copy\nconst original = { a: 1, b: { c: 2 } };\nconst shallow = { ...original };\nshallow.b.c = 3;\nconsole.log(original.b.c); // 3\n\n// Deep Copy\nconst deepCopy = JSON.parse(JSON.stringify(original));\ndeepCopy.b.c = 4;\nconsole.log(original.b.c); // 3\n</code></pre>\n  </pre>"},{"location":"js/concepts/#strings","title":"Strings","text":"JavaScript Strings <p>What is a String in JavaScript?</p> <p>     A string in JavaScript is a sequence of characters used to represent text. Strings are immutable, meaning once created, their values cannot be changed. Strings can be enclosed in single quotes (`'`), double quotes (`\"`), or backticks (`` ` ``).   </p> <pre>\n    <pre><code>let str1 = 'Hello';\nlet str2 = \"World\";\nlet str3 = `Hello, World!`;\nconsole.log(str3); // Hello, World!\n</code></pre>\n  </pre> <p>String Length</p> <p>     The `length` property of a string returns the number of characters in the string.   </p> <pre>\n    <pre><code>let str = \"Hello, World!\";\nconsole.log(str.length); // 13\n</code></pre>\n  </pre> <p>String Methods</p> <p>charAt()</p> <p>     The `charAt()` method returns the character at a specified index (position) in a string.   </p> <pre>\n    <pre><code>let str = \"JavaScript\";\nconsole.log(str.charAt(4)); // S\n</code></pre>\n  </pre> <p>indexOf()</p> <p>     The `indexOf()` method returns the index of the first occurrence of a specified value in a string. If the value is not found, it returns `-1`.   </p> <pre>\n    <pre><code>let str = \"Hello, World!\";\nconsole.log(str.indexOf(\"World\")); // 7\n</code></pre>\n  </pre> <p>slice()</p> <p>     The `slice()` method extracts a section of a string and returns a new string. It takes two parameters: the starting index and the ending index (not inclusive).   </p> <pre>\n    <pre><code>let str = \"JavaScript\";\nconsole.log(str.slice(0, 4)); // Java\n</code></pre>\n  </pre> <p>substring()</p> <p>     The `substring()` method returns a new string between two specified indices. It behaves similarly to `slice()`, but with a few differences, such as treating negative indices as `0`.   </p> <pre>\n    <pre><code>let str = \"JavaScript\";\nconsole.log(str.substring(0, 4)); // Java\n</code></pre>\n  </pre> <p>replace()</p> <p>     The `replace()` method searches for a specified pattern (string or regular expression) and replaces it with a new substring.   </p> <pre>\n    <pre><code>let str = \"Hello, World!\";\nlet newStr = str.replace(\"World\", \"JavaScript\");\nconsole.log(newStr); // Hello, JavaScript!\n</code></pre>\n  </pre> <p>toLowerCase() and toUpperCase()</p> <p>     The `toLowerCase()` method converts all characters in a string to lowercase, while the `toUpperCase()` method converts all characters to uppercase.   </p> <pre>\n    <pre><code>let str = \"JavaScript\";\nconsole.log(str.toLowerCase()); // javascript\nconsole.log(str.toUpperCase()); // JAVASCRIPT\n</code></pre>\n  </pre> <p>trim()</p> <p>     The `trim()` method removes any leading and trailing whitespace from a string.   </p> <pre>\n    <pre><code>let str = \"  Hello, World!  \";\nconsole.log(str.trim()); // Hello, World!\n</code></pre>\n  </pre> <p>split()</p> <p>     The `split()` method splits a string into an array of substrings based on a specified separator.   </p> <pre>\n    <pre><code>let str = \"Apple, Banana, Cherry\";\nlet arr = str.split(\", \");\nconsole.log(arr); // [\"Apple\", \"Banana\", \"Cherry\"]\n</code></pre>\n  </pre> <p>concat()</p> <p>     The `concat()` method is used to join two or more strings together.   </p> <pre>\n    <pre><code>let str1 = \"Hello\";\nlet str2 = \"World\";\nlet result = str1.concat(\", \", str2);\nconsole.log(result); // Hello, World\n</code></pre>\n  </pre> <p>startsWith() and endsWith()</p> <p>     The `startsWith()` method checks if a string starts with a specified substring, while `endsWith()` checks if it ends with a specified substring.   </p> <pre>\n    <pre><code>let str = \"Hello, World!\";\nconsole.log(str.startsWith(\"Hello\")); // true\nconsole.log(str.endsWith(\"!\")); // true\n</code></pre>\n  </pre> <p>includes()</p> <p>     The `includes()` method checks if a string contains a specified substring, returning `true` if found and `false` otherwise.   </p> <pre>\n    <pre><code>let str = \"Hello, World!\";\nconsole.log(str.includes(\"World\")); // true\nconsole.log(str.includes(\"world\")); // false\n</code></pre>\n  </pre> <p>repeat()</p> <p>     The `repeat()` method returns a new string that repeats the original string a specified number of times.   </p> <pre>\n    <pre><code>let str = \"JavaScript \";\nconsole.log(str.repeat(3)); // JavaScript JavaScript JavaScript \n</code></pre>\n  </pre> <p>String Template Literals</p> <p>     Template literals, denoted by backticks (`` ` ``), allow you to embed expressions within a string. This makes string concatenation and formatting easier.   </p> <pre>\n    <pre><code>let name = \"John\";\nlet age = 30;\nlet greeting = `Hello, my name is ${name} and I am ${age} years old.`;\nconsole.log(greeting); // Hello, my name is John and I am 30 years old.\n</code></pre>\n  </pre> <p>Escape Characters</p> <p>     Escape characters are used in strings to represent special characters that cannot be typed directly or need to be escaped for syntax reasons. Some common escape characters include:     <ul> <li><code>\\n</code> - Newline</li> <li><code>\\t</code> - Tab</li> <li><code>\\\\</code> - Backslash</li> <li><code>\\'</code> - Single quote</li> <li><code>\\\"</code> - Double quote</li> </ul> </p> <pre>\n    <pre><code>let str = \"Hello,\\nWorld!\";\nconsole.log(str); \n// Output: \n// Hello,\n// World!\n</code></pre>\n  </pre> <p>Unicode and Special Characters</p> <p>     You can represent special characters and characters from other languages using Unicode escape sequences. For example, `<code>\\uXXXX</code>` allows you to insert a Unicode character in the string.   </p> <pre>\n    <pre><code>let str = \"\\u00A9 2024 JavaScript\";\nconsole.log(str); // \u00a9 2024 JavaScript\n</code></pre>\n  </pre> <p>Important Notes</p> <ul> <li>Strings in JavaScript are immutable. You can't modify the content of a string directly. Instead, you must create a new string.</li> <li>Strings are indexed by their characters, starting at index `0`.</li> <li>Most of the string methods return a new string and do not modify the original string.</li> <li>You can use template literals for multi-line strings or embedded expressions.</li> </ul>"},{"location":"js/concepts/#arrays","title":"Arrays","text":"JavaScript Arrays <p>What is an Array in JavaScript?</p> <p>     An array in JavaScript is a list-like object used to store multiple values in a single variable. Arrays are ordered collections, meaning the values are indexed, and the elements in an array can be accessed using these indexes.     Arrays are dynamic in nature, meaning their size can change during execution.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3, 4, 5];\nconsole.log(arr); // [1, 2, 3, 4, 5]\n</code></pre>\n  </pre> <p>Array Length</p> <p>     The `length` property of an array returns the number of elements in the array. It can be used to determine the size of the array.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3, 4, 5];\nconsole.log(arr.length); // 5\n</code></pre>\n  </pre> <p>Accessing Array Elements</p> <p>     Array elements can be accessed using their index, starting from `0` for the first element.   </p> <pre>\n    <pre><code>let arr = ['apple', 'banana', 'cherry'];\nconsole.log(arr[1]); // banana\n</code></pre>\n  </pre> <p>Array Methods</p> <p>push()</p> <p>     The `push()` method adds one or more elements to the end of an array and returns the new array length.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3];\narr.push(4);\nconsole.log(arr); // [1, 2, 3, 4]\n</code></pre>\n  </pre> <p>pop()</p> <p>     The `pop()` method removes the last element from an array and returns that element.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3];\nlet removed = arr.pop();\nconsole.log(arr); // [1, 2]\nconsole.log(removed); // 3\n</code></pre>\n  </pre> <p>shift()</p> <p>     The `shift()` method removes the first element from an array and returns that element.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3];\nlet removed = arr.shift();\nconsole.log(arr); // [2, 3]\nconsole.log(removed); // 1\n</code></pre>\n  </pre> <p>unshift()</p> <p>     The `unshift()` method adds one or more elements to the beginning of an array and returns the new length of the array.   </p> <pre>\n    <pre><code>let arr = [2, 3];\narr.unshift(1);\nconsole.log(arr); // [1, 2, 3]\n</code></pre>\n  </pre> <p>concat()</p> <p>     The `concat()` method combines two or more arrays or values and returns a new array.   </p> <pre>\n    <pre><code>let arr1 = [1, 2];\nlet arr2 = [3, 4];\nlet result = arr1.concat(arr2);\nconsole.log(result); // [1, 2, 3, 4]\n</code></pre>\n  </pre> <p>slice()</p> <p>     The `slice()` method returns a shallow copy of a portion of an array into a new array. It takes two arguments: start index and end index (not inclusive).   </p> <pre>\n    <pre><code>let arr = [1, 2, 3, 4, 5];\nlet sliced = arr.slice(1, 4);\nconsole.log(sliced); // [2, 3, 4]\n</code></pre>\n  </pre> <p>splice()</p> <p>     The `splice()` method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3, 4, 5];\narr.splice(2, 1, 'a', 'b');\nconsole.log(arr); // [1, 2, 'a', 'b', 4, 5]\n</code></pre>\n  </pre> <p>forEach()</p> <p>     The `forEach()` method executes a provided function once for each array element.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3];\narr.forEach(element =&gt; console.log(element)); // 1 2 3\n</code></pre>\n  </pre> <p>map()</p> <p>     The `map()` method creates a new array populated with the results of calling a provided function on every element in the array.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3];\nlet result = arr.map(x =&gt; x * 2);\nconsole.log(result); // [2, 4, 6]\n</code></pre>\n  </pre> <p>filter()</p> <p>     The `filter()` method creates a new array with all elements that pass the test implemented by the provided function.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3, 4, 5];\nlet result = arr.filter(x =&gt; x &gt; 2);\nconsole.log(result); // [3, 4, 5]\n</code></pre>\n  </pre> <p>reduce()</p> <p>     The `reduce()` method applies a function to each element in the array (from left to right) to reduce it to a single value.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3, 4];\nlet sum = arr.reduce((acc, curr) =&gt; acc + curr, 0);\nconsole.log(sum); // 10\n</code></pre>\n  </pre> <p>find()</p> <p>     The `find()` method returns the first element in the array that satisfies the provided testing function.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3, 4];\nlet result = arr.find(x =&gt; x &gt; 2);\nconsole.log(result); // 3\n</code></pre>\n  </pre> <p>indexOf()</p> <p>     The `indexOf()` method returns the index of the first occurrence of a specified value in the array. If the value is not found, it returns `-1`.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3, 4];\nconsole.log(arr.indexOf(3)); // 2\nconsole.log(arr.indexOf(5)); // -1\n</code></pre>\n  </pre> <p>sort()</p> <p>     The `sort()` method sorts the elements of an array in place and returns the sorted array.   </p> <pre>\n    <pre><code>let arr = [4, 2, 3, 1];\narr.sort();\nconsole.log(arr); // [1, 2, 3, 4]\n</code></pre>\n  </pre> <p>reverse()</p> <p>     The `reverse()` method reverses the order of the elements in an array in place.   </p> <pre>\n    <pre><code>let arr = [1, 2, 3, 4];\narr.reverse();\nconsole.log(arr); // [4, 3, 2, 1]\n</code></pre>\n  </pre> <p>flat()</p> <p>     The `flat()` method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.   </p> <pre>\n    ```javascript\n    let arr = [1, [2, [3, 4]], 5];\n    let flattened = arr.flat(2);\n    console\n  ```"},{"location":"js/concepts/#objects","title":"Objects","text":"JavaScript Objects\n\n  <p>Overview</p>\n  <p>\n    In JavaScript, an object is a standalone entity, with properties and types. It's similar to real-life objects, where each object has characteristics (properties) and behavior (methods). Objects are key-value pairs where the key is always a string (or Symbol), and the value can be any data type, including other objects.\n  </p>\n\n  <p>Creating Objects</p>\n  <pre>\n    <pre><code>// Using Object Literal Syntax\nlet person = {\n  name: \"John\",\n  age: 30,\n  greet: function() { console.log(\"Hello!\"); }\n};\n\n// Using the Object constructor\nlet car = new Object();\ncar.make = \"Toyota\";\ncar.model = \"Corolla\";\ncar.year = 2020;\n</code></pre>\n  </pre>\n\n  <p>Accessing Object Properties</p>\n  <p>\n    There are two ways to access properties of an object: dot notation and bracket notation.\n  </p>\n  <pre>\n    <pre><code>let person = { name: \"John\", age: 30 };\nconsole.log(person.name);  // Dot notation\nconsole.log(person[\"age\"]); // Bracket notation\n</code></pre>\n  </pre>\n\n  <p>Modifying Object Properties</p>\n  <pre>\n    <pre><code>let person = { name: \"John\", age: 30 };\nperson.age = 31;                // Modifies the existing property\nperson[\"name\"] = \"Doe\";         // Modifies the property using bracket notation\n</code></pre>\n  </pre>\n\n  <p>Adding New Properties</p>\n  <pre>\n    <pre><code>let person = { name: \"John\" };\nperson.age = 30;               // Adding a new property using dot notation\nperson[\"address\"] = \"New York\"; // Adding a new property using bracket notation\n</code></pre>\n  </pre>\n\n  <p>Deleting Properties</p>\n  <pre>\n    <pre><code>let person = { name: \"John\", age: 30 };\ndelete person.age;  // Removes the 'age' property from the object\n</code></pre>\n  </pre>\n\n  <p>Methods in Objects</p>\n  <p>\n    An object can also contain methods, which are functions associated with the object. Methods are defined using function syntax and can be called using dot notation.\n  </p>\n  <pre>\n    <pre><code>let person = {\n  name: \"John\",\n  greet: function() {\n    console.log(\"Hello, \" + this.name);\n  }\n};\n\nperson.greet();  // Outputs: \"Hello, John\"\n</code></pre>\n  </pre>\n\n  <p>this Keyword</p>\n  <p>\n    Inside an object's method, `this` refers to the object itself. It allows you to access properties and methods of the current object.\n  </p>\n  <pre>\n    <pre><code>let person = {\n  name: \"John\",\n  greet: function() {\n    console.log(\"Hello, \" + this.name);\n  }\n};\n\nperson.greet();  // \"Hello, John\"\n</code></pre>\n  </pre>\n\n  <p>Object Methods</p>\n  <p>JavaScript provides several built-in methods for working with objects:</p>\n  <ul>\n    <li>Object.keys(obj) - Returns an array of the object's own property names (keys).</li>\n    <li>Object.values(obj) - Returns an array of the object's own property values.</li>\n    <li>Object.entries(obj) - Returns an array of key-value pairs for the object's properties.</li>\n    <li>Object.assign(target, source) - Copies all enumerable properties from one or more source objects to a target object.</li>\n    <li>Object.freeze(obj) - Freezes an object, preventing new properties from being added and existing properties from being modified or deleted.</li>\n    <li>Object.isFrozen(obj) - Checks if an object is frozen.</li>\n    <li>Object.hasOwnProperty(prop) - Checks if the object has a property with the specified name as its own property (not inherited).</li>\n  </ul>\n\n  <p>Object Destructuring</p>\n  <p>\n    Destructuring is a convenient way to extract values from an object and assign them to variables.\n  </p>\n  <pre>\n    <pre><code>const person = { name: \"John\", age: 30 };\nconst { name, age } = person;  // Destructuring\nconsole.log(name);  // John\nconsole.log(age);   // 30\n</code></pre>\n  </pre>\n\n  <p>Object Spread Syntax</p>\n  <p>\n    The spread syntax allows you to copy properties from one object to another, or merge multiple objects into one.\n  </p>\n  <pre>\n    <pre><code>const person = { name: \"John\", age: 30 };\nconst newPerson = { ...person, address: \"New York\" };\nconsole.log(newPerson);  // { name: \"John\", age: 30, address: \"New York\" }\n</code></pre>\n  </pre>\n\n  <p>Constructor Functions</p>\n  <p>\n    Constructor functions are a way to create reusable templates for creating new objects.\n  </p>\n  <pre>\n    <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nconst john = new Person(\"John\", 30);\nconsole.log(john.name);  // John\n</code></pre>\n  </pre>\n\n  <p>Object Prototypes</p>\n  <p>\n    Every JavaScript object has an internal prototype property, which allows objects to inherit properties and methods from other objects.\n  </p>\n  <pre>\n    <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.greet = function() {\n  console.log(\"Hello, \" + this.name);\n};\n\nconst john = new Person(\"John\", 30);\njohn.greet();  // Hello, John\n</code></pre>\n  </pre>\n\n  <p>Prototype Chain</p>\n  <p>\n    Objects in JavaScript are linked to other objects through a prototype chain. This chain is used to look up properties and methods that are not found on the object itself but on its prototype.\n  </p>\n  <pre>\n    <pre><code>function Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.sayHello = function() {\n  console.log(\"Hello, \" + this.name);\n};\n\nfunction Dog(name) {\n  Animal.call(this, name);  // Inherit from Animal\n}\n\nDog.prototype = Object.create(Animal.prototype);  // Link Dog prototype to Animal prototype\nDog.prototype.constructor = Dog;\n\nconst dog = new Dog(\"Rex\");\ndog.sayHello();  // Hello, Rex\n</code></pre>\n  </pre>\n  <ul>\n    <li>Creating Objects: You can create objects either using an object literal (<code>{}</code>) or the <code>new Object()</code> syntax.</li>\n    <li>Accessing Properties: You can access properties via dot notation (<code>object.property</code>) or bracket notation (<code>object['property']</code>).</li>\n    <li>Modifying and Adding Properties: Properties can be modified or added to an object using dot or bracket notation. Example: <code>object.property = newValue;</code></li>\n    <li>Methods in Objects: Functions stored as object properties are called methods. They can access other properties of the object via <code>this</code>. Example:\n      <pre>const person = {\n        name: 'Alice',\n        greet: function() {\n          console.log('Hello, ' + this.name);\n        }\n      }</pre>\n    </li>\n    <li>Object Methods: JavaScript provides built-in methods for object manipulation, such as <code>Object.keys()</code>, <code>Object.values()</code>, and <code>Object.assign()</code>. Example:\n      <pre>Object.keys(person); // ['name', 'greet']</pre>\n    </li>\n    <li>Destructuring: Allows easy extraction of properties from an object into variables. Example:\n      <pre>const { name, greet } = person;</pre>\n    </li>\n    <li>Spread Syntax: Allows merging objects or cloning objects in a concise way. Example:\n      <pre>const newPerson = {...person};</pre>\n    </li>\n    <li>Constructor Functions: Custom functions that act as templates for creating objects. Example:\n      <pre>function Person(name) {\n        this.name = name;\n      }\n      const person1 = new Person('John');</pre>\n    </li>\n    <li>Prototype and Prototype Chain: JavaScript objects inherit properties from a prototype chain, allowing object properties and methods to be shared. Example:\n      <pre>Object.getPrototypeOf(person);</pre>\n    </li>\n  </ul>"},{"location":"js/concepts/#built-in-features","title":"Built in features","text":"JavaScript Built-in Features: Map, Set, WeakMap, WeakSet\n\n  <p>Map</p>\n  <p>\n    A `Map` is a collection of key-value pairs where both the keys and the values can be of any data type (objects, primitives, etc.). Maps remember the insertion order of the keys, unlike objects, where the keys are always converted to strings.\n  </p>\n  <pre>\n    <pre><code>let map = new Map();\nmap.set('name', 'John');\nmap.set('age', 30);\nconsole.log(map.get('name')); // John\nconsole.log(map.has('age')); // true\nconsole.log(map.size); // 2\nmap.delete('age');\nconsole.log(map.has('age')); // false\nmap.clear();\nconsole.log(map.size); // 0\n</code></pre>\n  </pre>\n  <p>Common Methods:</p>\n  <ul>\n    <li>set(key, value) - Adds a new key-value pair to the Map or updates an existing one.</li>\n    <li>get(key) - Retrieves the value associated with the key.</li>\n    <li>has(key) - Returns true if the key exists, false otherwise.</li>\n    <li>delete(key) - Removes the key-value pair by key.</li>\n    <li>clear() - Removes all key-value pairs from the Map.</li>\n    <li>size - Returns the number of key-value pairs in the Map.</li>\n  </ul>\n\n  <p>Set</p>\n  <p>\n    A `Set` is a collection of unique values, where each value can only occur once. Sets are useful when you need to store a list of unique items without duplicates.\n  </p>\n  <pre>\n    <pre><code>let set = new Set();\nset.add(1);\nset.add(2);\nset.add(3);\nset.add(2); // Duplicates are ignored\nconsole.log(set); // Set { 1, 2, 3 }\nconsole.log(set.has(1)); // true\nconsole.log(set.size); // 3\nset.delete(2);\nconsole.log(set.has(2)); // false\nset.clear();\nconsole.log(set.size); // 0\n</code></pre>\n  </pre>\n  <p>Common Methods:</p>\n  <ul>\n    <li>add(value) - Adds a new value to the Set. If the value already exists, it does nothing.</li>\n    <li>has(value) - Checks if a value exists in the Set.</li>\n    <li>delete(value) - Removes the specified value from the Set.</li>\n    <li>clear() - Clears all values from the Set.</li>\n    <li>size - Returns the number of values in the Set.</li>\n  </ul>\n\n  <p>WeakMap\n  \n\n\n  Additional JavaScript Built-in Features\n\n  <p>Promise</p>\n  <p>\n    A `Promise` is an object representing the eventual completion or failure of an asynchronous operation. Promises are used to handle asynchronous operations in a more manageable way.\n  </p>\n  <pre>\n    <pre><code>let promise = new Promise((resolve, reject) =&gt; {\n  let success = true;\n  if (success) {\n    resolve(\"Operation successful!\");\n  } else {\n    reject(\"Operation failed!\");\n  }\n});\n\npromise.then(result =&gt; {\n  console.log(result);  // 'Operation successful!'\n}).catch(error =&gt; {\n  console.log(error);   // 'Operation failed!'\n});\n</code></pre>\n  </pre>\n  <p>Common Methods:</p>\n  <ul>\n    <li>then(onFulfilled, onRejected) - Adds fulfillment and rejection handlers to the promise.</li>\n    <li>catch(onRejected) - Adds a rejection handler to the promise.</li>\n    <li>finally(onFinally) - Adds a handler that will be invoked after the promise settles (either resolved or rejected).</li>\n    <li>Promise.all() - Returns a promise that resolves when all promises in an iterable have resolved.</li>\n    <li>Promise.race() - Returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects.</li>\n  </ul>\n\n  <p>Symbol</p>\n  <p>\n    `Symbol` is a primitive data type introduced in ES6 that is often used to create unique property keys. Each symbol is guaranteed to be unique and can be used as a property key to avoid name clashes.\n  </p>\n  <pre>\n    <pre><code>let symbol1 = Symbol('desc');\nlet symbol2 = Symbol('desc');\nconsole.log(symbol1 === symbol2); // false (unique symbols)\n</code></pre>\n  </pre>\n  <p>Common Use:</p>\n  <ul>\n    <li>Used for unique object property keys, to avoid property name conflicts.</li>\n    <li>Commonly used in metaprogramming for defining internal object behavior (e.g., `Symbol.iterator`).</li>\n  </ul>\n\n  <p>ArrayBuffer</p>\n  <p>\n    An `ArrayBuffer` is a low-level object used to represent binary data in JavaScript. It is commonly used in situations where data needs to be read or written to byte-oriented buffers, such as in Web APIs like `fetch` and `WebSockets`.\n  </p>\n  <pre>\n    <pre><code>let buffer = new ArrayBuffer(16);  // Creates a buffer with 16 bytes\nlet view = new DataView(buffer);   // Creates a DataView to interact with the buffer\nview.setInt8(0, 42);               // Sets the first byte to 42\nconsole.log(view.getInt8(0));      // 42\n</code></pre>\n  </pre>\n  <p>Common Use:</p>\n  <ul>\n    <li>Used for handling binary data in APIs such as `WebSockets`, `fetch`, and `FileReader`.</li>\n    <li>Commonly used in combination with typed arrays like `Int8Array`, `Uint8Array`, `Float32Array`, etc.</li>\n  </ul>\n\n  <p>Date</p>\n  <p>\n    The `Date` object is used for handling dates and times in JavaScript. It provides methods for parsing, formatting, and manipulating date and time values.\n  </p>\n  <pre>\n    <pre><code>let now = new Date();\nconsole.log(now);                 // Current date and time\nlet specificDate = new Date(2024, 0, 1); // January 1, 2024\nconsole.log(specificDate);        // Date object representing January 1, 2024\nconsole.log(specificDate.getFullYear()); // 2024\n</code></pre>\n  </pre>\n  <p>Common Methods:</p>\n  <ul>\n    <li>getDate() - Returns the day of the month.</li>\n    <li>getMonth() - Returns the month (0-11).</li>\n    <li>getFullYear() - Returns the 4-digit year.</li>\n    <li>getTime() - Returns the number of milliseconds since January 1, 1970.</li>\n    <li>toLocaleString() - Formats the date and time according to the local timezone and locale.</li>\n  </ul>\n\n  <p>Error</p>\n  <p>\n    The `Error` object is used to represent runtime errors in JavaScript. It is also the base object for custom error types like `SyntaxError`, `ReferenceError`, and `TypeError`.\n  </p>\n  <pre>\n    <pre><code>try {\n  throw new Error(\"Something went wrong!\");\n} catch (e) {\n  console.log(e.message);  // 'Something went wrong!'\n}\n</code></pre>\n  </pre>\n  <p>Common Error Types:</p>\n  <ul>\n    <li>SyntaxError - Raised when there is a syntax mistake in the code.</li>\n    <li>ReferenceError - Raised when a reference is made to a variable that does not exist.</li>\n    <li>TypeError - Raised when a value is not of the expected type.</li>\n    <li>RangeError - Raised when a value is not within an allowable range.</li>\n  </ul>\n\n  <p>RegExp</p>\n  <p>\n    The `RegExp` object is used for matching patterns in strings. Regular expressions provide powerful text-processing tools and are used extensively for tasks like validation, pattern searching, and replacement.\n  </p>\n  <pre>\n    <pre><code>let regex = /foo/;\nlet str = \"foobar\";\nconsole.log(regex.test(str)); // true\nlet result = str.replace(/foo/, \"bar\");\nconsole.log(result); // \"barbar\"\n</code></pre>\n  </pre>\n  <p>Common Methods:</p>\n  <ul>\n    <li>test() - Tests whether a pattern exists in a string, returns true or false.</li>\n    <li>exec() - Executes a search for a match in a string and returns an array of matched results.</li>\n    <li>match() - Used on a string to return an array of all matches of the regular expression.</li>\n    <li>replace() - Used to replace matched substrings with a new string.</li>\n  </ul>"},{"location":"js/concepts/#asynchronous-programming","title":"Asynchronous Programming","text":"JavaScript Asynchronous Programming\n\n  <p>Overview</p>\n  <p>\n    Asynchronous programming in JavaScript allows non-blocking code execution. This is especially useful when dealing with I/O-bound tasks such as reading from files, making HTTP requests, or accessing databases. By using asynchronous programming techniques, JavaScript can execute tasks without freezing the main thread, providing a smoother user experience.\n  </p>\n\n  <p>Why Asynchronous Programming?</p>\n  <p>\n    JavaScript is single-threaded, meaning it can only execute one operation at a time. However, when dealing with tasks that take time (e.g., reading data from a server), it is inefficient to block the entire program while waiting for the task to complete. Asynchronous programming allows JavaScript to initiate a task, continue executing other code, and handle the task when it completes.\n  </p>\n\n  <p>Key Concepts</p>\n\n  <ul>\n    <li>Callback Functions: Functions passed as arguments to other functions to be called once a task completes.</li>\n    <li>Promises: Objects that represent the eventual completion (or failure) of an asynchronous operation.</li>\n    <li>Async/Await: A syntax for working with promises in a more synchronous manner, making code more readable.</li>\n  </ul>\n\n  <p>1. Callback Functions</p>\n  <p>\n    A callback is a function passed as an argument to another function and executed after the completion of an asynchronous operation.\n  </p>\n  <pre>\n    <pre><code>// Simple example of callback usage\nfunction fetchData(callback) {\n  setTimeout(() =&gt; {\n    callback(\"Data received!\");\n  }, 2000);\n}\n\nfetchData((data) =&gt; {\n  console.log(data);  // Outputs: Data received!\n});\n</code></pre>\n  </pre>\n\n  <p>Callback Hell</p>\n  <p>\n    A common issue with callbacks is \"callback hell\", where callbacks are nested within each other, leading to hard-to-maintain code. This issue is often addressed using Promises or Async/Await.\n  </p>\n  <pre>\n    <pre><code>fetchData((data) =&gt; {\n  console.log(data);\n  fetchMoreData((moreData) =&gt; {\n    console.log(moreData);\n    fetchFinalData((finalData) =&gt; {\n      console.log(finalData);\n    });\n  });\n});\n</code></pre>\n  </pre>\n\n  <p>2. Promises</p>\n  <p>\n    A promise represents a value that may be available now, or in the future, or never. It is an object that can be in one of three states: pending, resolved (fulfilled), or rejected.\n  </p>\n  <pre>\n    <pre><code>// Creating a Promise\nlet promise = new Promise((resolve, reject) =&gt; {\n  let success = true;  // Simulate success or failure\n  if (success) {\n    resolve(\"Operation successful!\");\n  } else {\n    reject(\"Operation failed.\");\n  }\n});\n\n// Handling the Promise\npromise\n  .then((result) =&gt; {\n    console.log(result);  // Outputs: Operation successful!\n  })\n  .catch((error) =&gt; {\n    console.error(error);  // Outputs: Operation failed.\n  });\n</code></pre>\n  </pre>\n\n  <p>Promise Chaining</p>\n  <p>\n    Promises can be chained, allowing you to execute multiple asynchronous operations sequentially.\n  </p>\n  <pre>\n    <pre><code>function fetchData() {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(\"Data received\");\n    }, 2000);\n  });\n}\n\nfetchData()\n  .then((data) =&gt; {\n    console.log(data);  // Outputs: Data received\n    return \"More data\";\n  })\n  .then((moreData) =&gt; {\n    console.log(moreData);  // Outputs: More data\n  })\n  .catch((error) =&gt; {\n    console.log(error);\n  });\n</code></pre>\n  </pre>\n\n  <p>3. Async/Await</p>\n  <p>\n    Async/Await is a more modern and cleaner way of handling asynchronous operations. `async` functions always return a Promise. The `await` keyword can be used to wait for a Promise to resolve or reject before proceeding to the next line of code.\n  </p>\n  <pre>\n    <pre><code>// Using Async/Await\nasync function fetchData() {\n  let data = await new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(\"Data received!\");\n    }, 2000);\n  });\n  console.log(data);  // Outputs: Data received!\n}\n\nfetchData();\n</code></pre>\n  </pre>\n\n  <p>Handling Multiple Promises</p>\n  <p>\n    You can handle multiple promises simultaneously using methods like `Promise.all()`, `Promise.allSettled()`, `Promise.race()`, and `Promise.any()`.\n  </p>\n\n  <ul>\n    <li>Promise.all(): Waits for all promises to resolve or any to reject.</li>\n    <li>Promise.allSettled(): Waits for all promises to settle (either resolved or rejected).</li>\n    <li>Promise.race(): Resolves or rejects as soon as the first promise resolves or rejects.</li>\n    <li>Promise.any(): Resolves when the first promise resolves, ignoring rejected promises.</li>\n  </ul>\n  <pre>\n    <pre><code>// Using Promise.all\nlet promise1 = new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(\"First\"), 1000));\nlet promise2 = new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(\"Second\"), 2000));\n\nPromise.all([promise1, promise2]).then((values) =&gt; {\n  console.log(values);  // Outputs: [\"First\", \"Second\"]\n});\n\n// Using Promise.race\nPromise.race([promise1, promise2]).then((value) =&gt; {\n  console.log(value);  // Outputs: First (because it's resolved first)\n});\n</code></pre>\n  </pre>\n\n  <p>4. Error Handling with Async/Await</p>\n  <p>\n    When using async/await, you can handle errors using try-catch blocks, similar to synchronous code.\n  </p>\n  <pre>\n    <pre><code>async function fetchData() {\n  try {\n    let data = await new Promise((resolve, reject) =&gt; {\n      let success = false;\n      if (success) {\n        resolve(\"Data fetched successfully\");\n      } else {\n        reject(\"Error fetching data\");\n      }\n    });\n    console.log(data);\n  } catch (error) {\n    console.error(error);  // Outputs: Error fetching data\n  }\n}\n\nfetchData();\n</code></pre>\n  </pre>\n\n  <p>5. Event Loop and Callbacks</p>\n  <p>\n    The JavaScript event loop is responsible for managing the execution of multiple pieces of code, ensuring that the main thread is not blocked. Asynchronous callbacks are placed in the **callback queue**, and once the stack is empty, the event loop moves callbacks to the call stack for execution.\n  </p>\n  <pre>\n    <pre><code>console.log(\"Start\");\n\nsetTimeout(() =&gt; {\n  console.log(\"Async Task\");\n}, 2000);\n\nconsole.log(\"End\");\n</code></pre>\n    <p>Outputs:</p>\n    <pre>Start</pre>\n    <pre>End</pre>\n    <pre>Async Task</pre>\n  </pre>\n\n  <p>6. Conclusion</p>\n  <p>\n    Asynchronous programming is essential for handling time-consuming tasks in JavaScript. By using callbacks, promises, or async/await, JavaScript provides powerful ways to manage concurrency without blocking the execution of other code. Understanding how asynchronous code works is key to building efficient and responsive applications.\n  </p>\n  Key Concepts:\n<ul>\n    <li>Callback Functions: Functions that are passed as arguments to other functions to execute after an asynchronous task is complete.</li>\n    <li>Promises: Objects representing the eventual completion (or failure) of an asynchronous operation. Promises allow better chaining and error handling compared to callbacks.</li>\n    <li>Async/Await: A modern syntax for working with promises that allows writing asynchronous code in a more synchronous, readable style.</li>\n    <li>Error Handling: `try-catch` can be used for error handling in async functions to catch errors from promises.</li>\n    <li>Event Loop: Manages asynchronous tasks in JavaScript, ensuring the main thread is not blocked by time-consuming tasks.</li>\n    <li>Promise Methods: Methods like `Promise.all()`, `Promise.allSettled()`, `Promise.race()`, and `Promise.any()` provide powerful ways to work with multiple promises.</li>\n  </ul>"},{"location":"js/namasteJs/","title":"NamsteJs","text":"1. How js Works <pre><code>    Js creates global execution context has two components\n    1. memory component alias variable environment\n        * creates memory before code execution for var and fucniton syntax\n            var as undefined\n            function with its syntax\n    2. code component\n        * executes code line by line \n</code></pre>  2. How js code is executed <pre><code>on Every fucntion invocation js engine creates a exectuion context in a call stack\n* in call stack on fucniton invocation new memroy component and new code component gets \n    - upon completion of that function it deletes the executuion context\n</code></pre>  3. Hoisting in js  <pre><code>    its the behaviour of js where the decalred variables and fucniton will be moved to top of its scope by \n    allocation memory for var as undefined and whole fucntion syntax, so if any code tries to  access var or fucniton befores it declaration, it will not result in error. var will result in undefined and function can be invoked\n</code></pre>  4. Functions work in js <pre><code>    - in mnormal funcitons it can be invoked before its declaration because of hoisting. \n    but not in the case of function where assigned to variable. that function will be treated as variable only\n</code></pre>  5. Shortest js <pre><code>    - without any line of code still it will be a js program\n    * browser will create a global object as window\n    * this refers to window object\n</code></pre>  6. undefined vs not defined <pre><code>- undefined: memory allocated for variable but no value has been assigned\n- not defined: no reference for this variable in the memory\n</code></pre>  7. Scope, Scope chain, Lexical env <pre><code>- Scope: scope defines the accessibility of a variable\n- Scope chain: where the code execution looks for a variable in its memory component along with its lexical env \n    if js engine does not find variable in its local memory, it goes for next scope of chain\n- lexical Env: an Execution context's memory componet and its parent execution context memory component\n</code></pre>  8. let &amp; const <pre><code>    let : cannot redeclare, can re-assign \n     hoisting happpens but if tries to access before its declaration will result in temperol deadzone\n    const: cannot redeclare,should initialize on declaration itself, reassign will result in type error\n    reference error: unable to trace a variable in its memory\n    syntax error: code validation failed. willl not run program\n    type error: ex: tried to re assign value of constant which is not allowed\n</code></pre> <ol> <li>Block Scope </li> <li>Qna</li> <li>Closures</li> <li>setTimeout + closures interview</li> <li>Js interview</li> <li>First class fucnitons</li> <li>callBack Fucnitons</li> <li>Asynchronous Js &amp; event loop</li> <li>JS engine</li> <li>trsust issues with setTimeout()</li> <li>Higher Order funcitons</li> <li>map, filter, reduce</li> </ol>"},{"location":"js/test/","title":"JavaScript Overview and Interview Questions","text":""},{"location":"js/test/#overview","title":"Overview","text":"<p>JavaScript is a dynamic, interpreted programming language that runs in the browser or on a server (Node.js). It is single-threaded, meaning that it can only execute one operation at a time. However, JavaScript uses certain concepts such as execution context, call stack, and hoisting to handle various operations in a way that provides asynchronous behavior and manages multiple tasks.</p> Concept Explanation Examples Execution Context Holds information about the environment in which the current code is executed. Defines the scope, variable values, and function executions. - Global Execution Context: Default context for global code execution.  - Function Execution Context: Created when a function is invoked.  - Eval Execution Context: Rarely used, when code is executed inside an <code>eval()</code>. Components of Execution Context Contains:  - Variable Environment: Holds variables, functions, and parameters.  - Lexical Environment: Contains variables declared in the current scope.  - This Binding: Refers to the object executing the current code. Variable Environment Refers to where variables and functions are stored during code execution, managing scope and access. - Local Variables: Variables declared inside a function.  - Function Parameters: Arguments passed into a function.  - Function Declarations: Functions in the current scope. Call Stack A stack data structure used to track function calls. When a function is invoked, its execution context is pushed onto the stack. Once the function execution completes, the context is popped off. - The Call Stack keeps track of the order of function execution.  Example: <code>function a() { b(); } function b() { console.log('Hello'); }</code> Call stack: <code>a()</code> \u2192 <code>b()</code>. Event Loop The event loop constantly checks the call stack and callback queue. If the call stack is empty, it pushes the first callback from the callback queue to the call stack for execution. - The Event Loop allows asynchronous code (like <code>setTimeout</code> or promises) to be executed once the call stack is clear.  Example: <code>setTimeout(() =&gt; { console.log('Done'); }, 1000);</code> Garbage Collector A mechanism that automatically frees up memory by cleaning up unused objects that are no longer referenced. The garbage collector works in the background without direct developer intervention. - The Garbage Collector runs periodically to identify and remove objects that are no longer needed or referenced.  Example: <code>let obj = { name: 'Test' }; obj = null;</code> (The object is now eligible for garbage collection). Example (Thread Execution) When a function is called, it is pushed onto the call stack. Asynchronous code moves callbacks to the event loop's callback queue. When the stack is empty, the event loop executes them. <code>function example() { let x = 10; console.log(x); } example();</code> <code>x</code> is stored in the function\u2019s execution context."},{"location":"js/test/#es5-features","title":"ES5 features","text":"Version Feature Description Example ES5 Strict Mode Introduced strict mode to catch common coding errors and improve performance. <code>'use strict'; &lt;br&gt; var x = 10; &lt;br&gt; delete x; // Error</code> Array Methods New methods like <code>forEach()</code>, <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, and <code>some()</code> to simplify array operations. <code>arr.forEach(item =&gt; console.log(item)); &lt;br&gt; arr.map(x =&gt; x * 2);</code> JSON The <code>JSON</code> object was introduced to parse and stringify JSON data. <code>JSON.parse('{\"name\": \"John\"}'); &lt;br&gt; JSON.stringify({name: \"John\"});</code> Object Methods Added <code>Object.create()</code>, <code>Object.defineProperty()</code>, <code>Object.defineProperties()</code>, <code>Object.getOwnPropertyNames()</code>. <code>Object.create(null); &lt;br&gt; Object.defineProperty(obj, 'prop', { value: 42 });</code> ES6 Arrow Functions Introduced a shorter syntax for functions and lexical <code>this</code> binding. <code>const sum = (a, b) =&gt; a + b;</code> Let and Const Introduced block-scoped variables (<code>let</code>) and constants (<code>const</code>). <code>let x = 10; &lt;br&gt; const y = 20;</code> Template Literals String interpolation with backticks and expression embedding. <code>let str = `Hello, ${name}`</code> Destructuring Assignment Assign variables from arrays or objects in a concise way. <code>const [a, b] = [1, 2]; &lt;br&gt; const {x, y} = obj;</code> Default Parameters Parameters can have default values. <code>function greet(name = 'Guest') { console.log(name); }</code> Promises Native support for promises to handle asynchronous operations. <code>new Promise((resolve, reject) =&gt; { resolve('Done'); }).then(data =&gt; console.log(data));</code> Classes Introduced class syntax for object-oriented programming. <code>class Person { constructor(name) { this.name = name; } }</code> Modules Introduced the <code>import</code> and <code>export</code> statements to support modular code. <code>import { add } from './math.js'; &lt;br&gt; export function add(a, b) { return a + b; }</code> ES7 Array.prototype.includes() Added <code>includes()</code> to check if an element exists in an array. <code>[1, 2, 3].includes(2); // true</code> Exponentiation Operator Introduced the exponentiation operator (<code>**</code>) for raising a number to a power. <code>2 ** 3; // 8</code> ES8 Async/Await Introduced async functions and the <code>await</code> keyword for handling promises more intuitively. <code>async function fetchData() { let result = await fetch('url'); return result.json(); }</code> Object.values() / Object.entries() Methods to return an array of values or an array of key-value pairs from an object. <code>Object.values({a: 1, b: 2}); // [1, 2]</code> <code>Object.entries({a: 1, b: 2}); // [['a', 1], ['b', 2]]</code> String padding Added <code>padStart()</code> and <code>padEnd()</code> to pad a string to a specified length. <code>'5'.padStart(3, '0'); // '005' &lt;br&gt; '5'.padEnd(3, '0'); // '500'</code> ES9 Asynchronous Iteration Introduced <code>for-await-of</code> for iterating over asynchronous data sources like promises. <code>async function printData() { for await (let data of fetchData()) { console.log(data); } }</code> Object Rest and Spread Properties Spread and rest properties were added for objects, enabling easier copying and merging of objects. <code>const obj = { ...sourceObj }; &lt;br&gt; const { a, b, ...rest } = obj;</code> ES10 Array.prototype.flat() Introduced <code>flat()</code> to flatten nested arrays into a single array. <code>[1, [2, [3]]].flat(2); // [1, 2, 3]</code> String.prototype.trimStart() / trimEnd() Methods to trim whitespace from the beginning or end of a string. <code>'  hello  '.trimStart(); // 'hello  ' &lt;br&gt; '  hello  '.trimEnd(); // '  hello'</code> Optional Catch Binding Allows <code>catch</code> to omit the error parameter if not needed. <code>try { throw new Error(); } catch { console.log('Error caught'); }</code> ES11 Nullish Coalescing Operator (??) Introduced the nullish coalescing operator to return the right-hand operand only when the left-hand is <code>null</code> or <code>undefined</code>. <code>let result = a ?? b; // Returns b if a is null or undefined</code> Optional Chaining (?.) Allows safe access to nested properties without throwing errors when a property is <code>null</code> or <code>undefined</code>. <code>let name = person?.address?.street; // Returns undefined if any part is null or undefined</code> BigInt Added support for large integers beyond the <code>Number</code> type. <code>let bigInt = 1234567890123456789012345678901234567890n;</code> Promise.allSettled() Returns a promise that resolves after all input promises have settled (either resolved or rejected). <code>Promise.allSettled([p1, p2]).then(results =&gt; console.log(results));</code> ES12 Logical Assignment Operators Combines logical operators (<code>&amp;&amp;</code>, <code>||</code>, <code>??</code>) with assignment. <code>x &amp;&amp;= y; &lt;br&gt; x ||= y; &lt;br&gt; x ??= y;</code> WeakRefs Introduced <code>WeakRef</code> and <code>FinalizationRegistry</code> for weak references, allowing objects to be garbage collected. <code>let ref = new WeakRef(obj);</code> Numeric Separators Introduced underscores as separators in numeric literals for better readability. <code>let num = 1_000_000; // 1000000</code> ES13 (Future) Top-level Await Allows <code>await</code> to be used at the top level in modules, without needing to wrap it inside an <code>async</code> function. <code>// In an ES module file &lt;br&gt; await fetch('data.json');</code> Logical Nullish Assignment (??=) Simplifies nullish coalescing assignment (combines <code>??</code> with <code>=</code>). <code>x ??= y; // Assign y only if x is null or undefined</code> Future Pattern Matching (proposal) Pattern matching (similar to switch statements) to match against complex patterns in JavaScript. <code>match (value) { case 1: return \"One\"; case [a, b]: return \"Pair\"; }</code>"},{"location":"js/test/#key-features","title":"Key Features","text":"<ol> <li>Dynamic Typing: Types are determined at runtime.</li> <li>Prototypal Inheritance: Objects inherit directly from other objects.</li> <li>Event-Driven: Used to handle events like user actions or server responses.</li> <li>Asynchronous Programming: Supports asynchronous operations with <code>callbacks</code>, <code>promises</code>, and <code>async/await</code>.</li> <li>Cross-Platform: Runs on all major browsers and environments like Node.js.</li> </ol>"},{"location":"js/test/#javascript-interview-questions-and-answers","title":"JavaScript Interview Questions and Answers","text":""},{"location":"js/test/#1-what-is-the-difference-between-var-let-and-const","title":"1. What is the difference between <code>var</code>, <code>let</code>, and <code>const</code>?","text":"<ul> <li><code>var</code>: Function-scoped, can be redeclared, and is hoisted.</li> <li><code>let</code>: Block-scoped, cannot be redeclared, and is not initialized during hoisting.</li> <li><code>const</code>: Block-scoped, must be initialized during declaration, and its value cannot be reassigned.</li> </ul>"},{"location":"js/test/#3-what-is-hoisting-in-javascript","title":"3. What is hoisting in JavaScript?","text":"<p>Hoisting is JavaScript's default behavior of moving declarations (variables and functions) to the top of their scope during compilation. However, only declarations are hoisted, not initializations. only var-undefined and functions-f{..} and let const would be in temporal deadzone</p>"},{"location":"js/test/#4-what-are-javascript-data-types","title":"4. What are JavaScript data types?","text":"<ul> <li>Primitive Types: <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Undefined</code>, <code>Null</code>, <code>BigInt</code>, <code>Symbol</code>.</li> <li>Non-Primitive Types: Objects (including arrays, functions, and objects).</li> </ul>"},{"location":"js/test/#5-what-are-closures-in-javascript","title":"5. What are closures in JavaScript?","text":"<p>A closure is a function that remembers the variables from its outer scope, even after the outer function has finished executing. Closures are used to create private variables and maintain state.</p>"},{"location":"js/test/#6-what-is-the-difference-between-and","title":"6. What is the difference between <code>==</code> and <code>===</code>?","text":"<ul> <li><code>==</code>: Checks for value equality and performs type coercion if the types differ.</li> <li><code>===</code>: Checks for both value and type equality without type coercion.</li> </ul>"},{"location":"js/test/#7-explain-the-concept-of-this-in-javascript","title":"7. Explain the concept of \"this\" in JavaScript.","text":"<p>The <code>this</code> keyword refers to the object that is currently executing the function. Its value depends on the function's context: - In a method, <code>this</code> refers to the object. - In a regular function, <code>this</code> refers to the global object (<code>window</code> in browsers, <code>global</code> in Node.js). - In strict mode, <code>this</code> is <code>undefined</code> for regular functions.</p>"},{"location":"js/test/#8-what-are-promises-in-javascript","title":"8. What are promises in JavaScript?","text":"<p>Promises are objects that represent the eventual completion (or failure) of an asynchronous operation. They have three states: - Pending: The operation is ongoing. - Resolved (Fulfilled): The operation completed successfully. - Rejected: The operation failed.</p>"},{"location":"js/test/#9-what-is-the-event-loop-in-javascript","title":"9. What is the event loop in JavaScript?","text":"<p>The event loop is a mechanism that handles and processes events and asynchronous tasks. It ensures non-blocking execution by continuously checking the call stack and callback queue, executing queued tasks when the call stack is empty.</p>"},{"location":"js/test/#web-specific-questions","title":"Web-Specific Questions","text":""},{"location":"js/test/#10-what-is-the-difference-between-synchronous-and-asynchronous-programming","title":"10. What is the difference between synchronous and asynchronous programming?","text":"<ul> <li>Synchronous: Tasks are executed sequentially, blocking further execution until the current task is completed.</li> <li>Asynchronous: Tasks can be executed independently of the main program flow, using mechanisms like callbacks, promises, or <code>async/await</code>.</li> </ul>"},{"location":"js/test/#11-what-are-javascript-events","title":"11. What are JavaScript Events?","text":"<p>Events are actions or occurrences that happen in the browser, such as clicks, keypresses, or page loads. JavaScript can respond to these events using event listeners.</p>"},{"location":"js/test/#12-what-are-arrow-functions-in-javascript","title":"12. What are Arrow Functions in JavaScript?","text":"<p>Arrow functions are a shorthand syntax for writing functions introduced in ES6. They do not have their own <code>this</code>, and thus inherit <code>this</code> from their lexical scope.</p>"},{"location":"js/test/#methods-in-javascript","title":"Methods in JavaScript","text":""},{"location":"js/test/#1-what-is-the-difference-between-call-apply-and-bind","title":"1. What is the difference between <code>.call()</code>, <code>.apply()</code>, and <code>.bind()</code>?","text":"<ul> <li><code>call()</code>: Invokes a function with a specified <code>this</code> context and arguments passed individually.</li> <li><code>apply()</code>: Similar to <code>call()</code> but takes arguments as an array.</li> <li><code>bind()</code>: Returns a new function with a specified <code>this</code> context, which can be invoked later.</li> </ul>"},{"location":"js/test/#2-what-are-javascript-array-methods","title":"2. What are JavaScript array methods?","text":"<ul> <li>Mutating Methods: <code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code>, <code>reverse()</code>, <code>sort()</code>.</li> <li>Non-Mutating Methods: <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>forEach()</code>, <code>find()</code>, <code>every()</code>, <code>some()</code>, <code>slice()</code>.</li> </ul>"},{"location":"js/test/#3-explain-map-filter-and-reduce-with-examples","title":"3. Explain <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> with examples.","text":"<ul> <li><code>map()</code>: Transforms an array by applying a function to each element and returns a new array.</li> <li><code>filter()</code>: Returns a new array containing elements that pass a specified condition.</li> <li><code>reduce()</code>: Reduces the array to a single value based on a callback function.</li> </ul>"},{"location":"js/test/#4-what-are-string-methods-in-javascript","title":"4. What are string methods in JavaScript?","text":"<ul> <li>Common methods:</li> <li><code>charAt()</code>, <code>concat()</code>, <code>includes()</code>, <code>indexOf()</code>, <code>replace()</code>, <code>split()</code>, <code>substring()</code>, <code>toLowerCase()</code>, <code>toUpperCase()</code>, <code>trim()</code>.</li> </ul>"},{"location":"js/test/#objects-and-prototypes","title":"Objects and Prototypes","text":""},{"location":"js/test/#5-what-is-the-difference-between-objectfreeze-and-objectseal","title":"5. What is the difference between Object.freeze() and Object.seal()?","text":"<ul> <li><code>Object.freeze()</code>: Prevents any modification (adding, deleting, or changing properties).</li> <li><code>Object.seal()</code>: Allows modification of existing properties but prevents adding or deleting properties.</li> </ul>"},{"location":"js/test/#6-what-are-getters-and-setters-in-javascript","title":"6. What are getters and setters in JavaScript?","text":"<p>Getters and setters are methods that provide controlled access to an object's properties. - Getter: Used to retrieve property values. - Setter: Used to set or update property values.</p>"},{"location":"js/test/#7-explain-prototypal-inheritance-in-javascript","title":"7. Explain prototypal inheritance in JavaScript.","text":"<p>Prototypal inheritance allows objects to inherit properties and methods from another object. Every JavaScript object has a prototype, which is another object it inherits from.</p>"},{"location":"js/test/#8-what-is-the-difference-between-objectcreate-and-class-inheritance","title":"8. What is the difference between Object.create() and class inheritance?","text":"<ul> <li><code>Object.create()</code>: Creates a new object with a specified prototype.</li> <li>Class inheritance: Introduced in ES6, uses the <code>class</code> and <code>extends</code> keywords to create a more structured inheritance model.</li> </ul>"},{"location":"js/test/#functions","title":"Functions","text":""},{"location":"js/test/#9-what-is-the-difference-between-a-regular-function-and-an-arrow-function","title":"9. What is the difference between a regular function and an arrow function?","text":"<ul> <li>Arrow Function:</li> <li>Does not have its own <code>this</code>.</li> <li>Cannot be used as a constructor.</li> <li>Has a more concise syntax.</li> <li>Regular Function:</li> <li>Has its own <code>this</code> context.</li> <li>Can be used as a constructor.</li> <li>Syntax can be verbose.</li> </ul>"},{"location":"js/test/#10-what-is-function-currying","title":"10. What is function currying?","text":"<p>Currying is a technique where a function is transformed into a series of functions, each accepting a single argument.</p>"},{"location":"js/test/#11-what-is-memoization","title":"11. What is memoization?","text":"<p>Memoization is an optimization technique where function results are cached for specific inputs to avoid redundant computations.</p>"},{"location":"js/test/#error-handling","title":"Error Handling","text":""},{"location":"js/test/#12-what-is-the-purpose-of-trycatch-in-javascript","title":"12. What is the purpose of <code>try...catch</code> in JavaScript?","text":"<p><code>try...catch</code> is used to handle runtime errors gracefully by wrapping code that might throw an error and providing a fallback mechanism in the <code>catch</code> block.</p>"},{"location":"js/test/#13-what-is-the-difference-between-throw-and-return","title":"13. What is the difference between <code>throw</code> and <code>return</code>?","text":"<ul> <li><code>throw</code>: Used to generate a custom error or exception.</li> <li><code>return</code>: Used to exit a function and return a value.</li> </ul>"},{"location":"js/test/#14-how-can-you-create-custom-errors-in-javascript","title":"14. How can you create custom errors in JavaScript?","text":"<p>Custom errors can be created by extending the built-in <code>Error</code> class and defining a custom constructor.</p>"},{"location":"js/test/#asynchronous-programming","title":"Asynchronous Programming","text":""},{"location":"js/test/#15-what-is-the-difference-between-settimeout-and-setinterval","title":"15. What is the difference between <code>setTimeout</code> and <code>setInterval</code>?","text":"<ul> <li><code>setTimeout</code>: Executes a function once after a specified delay.</li> <li><code>setInterval</code>: Repeatedly executes a function at a specified interval.</li> </ul>"},{"location":"js/test/#16-what-are-the-different-states-of-a-promise","title":"16. What are the different states of a Promise?","text":"<ul> <li>Pending: The initial state of the promise.</li> <li>Fulfilled: Indicates a successful operation.</li> <li>Rejected: Indicates a failed operation.</li> </ul>"},{"location":"js/test/#17-what-is-asyncawait-in-javascript","title":"17. What is <code>async/await</code> in JavaScript?","text":"<p><code>async/await</code> is a syntax introduced in ES8 to handle asynchronous operations in a more readable and synchronous-like manner.</p>"},{"location":"js/test/#18-what-is-the-purpose-of-promiseall-and-promiserace","title":"18. What is the purpose of <code>Promise.all</code> and <code>Promise.race</code>?","text":"<ul> <li><code>Promise.all</code>: Resolves when all promises in an array resolve, or rejects if any promise rejects.</li> <li><code>Promise.race</code>: Resolves or rejects as soon as the first promise in the array resolves or rejects.</li> </ul>"},{"location":"js/test/#event-handling-and-dom","title":"Event Handling and DOM","text":""},{"location":"js/test/#19-what-is-event-delegation","title":"19. What is event delegation?","text":"<p>Event delegation is a technique where a single event listener is attached to a parent element to handle events on its child elements.</p>"},{"location":"js/test/#20-what-is-the-difference-between-addeventlistener-and-inline-event-handlers","title":"20. What is the difference between <code>addEventListener</code> and inline event handlers?","text":"<ul> <li><code>addEventListener</code>: Allows multiple listeners for the same event and better separation of concerns.</li> <li>Inline Handlers: Embed JavaScript directly into HTML, which can lead to less maintainable code.</li> </ul>"},{"location":"js/test/#21-what-are-the-phases-of-event-propagation","title":"21. What are the phases of event propagation?","text":"<ol> <li>Capturing Phase: Events are captured from the root to the target element.</li> <li>Target Phase: The event reaches the target element.</li> <li>Bubbling Phase: Events bubble back up to the root.</li> </ol>"},{"location":"js/test/#miscellaneous","title":"Miscellaneous","text":""},{"location":"js/test/#22-what-is-the-difference-between-null-and-undefined","title":"22. What is the difference between <code>null</code> and <code>undefined</code>?","text":"<ul> <li><code>null</code>: Explicitly assigned to indicate \"no value.\"</li> <li><code>undefined</code>: Indicates a variable has been declared but not assigned a value.</li> </ul>"},{"location":"js/test/#23-what-is-a-symbol-in-javascript","title":"23. What is a <code>Symbol</code> in JavaScript?","text":"<p>A <code>Symbol</code> is a unique and immutable primitive data type introduced in ES6, often used as object property keys.</p>"},{"location":"js/test/#24-what-is-typeof-and-when-is-it-used","title":"24. What is <code>typeof</code> and when is it used?","text":"<p><code>typeof</code> is an operator used to determine the type of a variable or value (e.g., <code>typeof 42 // \"number\"</code>).</p>"},{"location":"js/test/#25-what-is-the-difference-between-shallow-and-deep-cloning-in-javascript","title":"25. What is the difference between shallow and deep cloning in JavaScript?","text":"<ul> <li>Shallow Cloning: Copies the top-level properties only (e.g., <code>Object.assign()</code>, spread operator <code>...</code>).</li> <li>Deep Cloning: Recursively copies all nested objects (e.g., <code>JSON.parse(JSON.stringify(obj))</code> or libraries like Lodash).</li> </ul>"},{"location":"js/test/#best-practices","title":"Best Practices","text":""},{"location":"js/test/#13-how-do-you-avoid-callback-hell","title":"13. How do you avoid callback hell?","text":"<ul> <li>Use Promises or async/await for better readability and maintainability.</li> <li>Modularize code by breaking it into smaller, reusable functions.</li> </ul>"},{"location":"js/test/#14-what-are-some-common-javascript-debugging-techniques","title":"14. What are some common JavaScript debugging techniques?","text":"<ul> <li>Use <code>console.log()</code> for simple debugging.</li> <li>Use browser developer tools for stepping through code and inspecting variables.</li> <li>Leverage breakpoints and the <code>debugger</code> keyword.</li> </ul>"},{"location":"js/test/#15-what-are-javascript-modules","title":"15. What are JavaScript modules?","text":"<p>Modules allow you to split your code into reusable, maintainable pieces. In ES6, the <code>import</code> and <code>export</code> keywords are used to define and use modules.</p>"},{"location":"programs/interview-programs/","title":"Interview Programs","text":""},{"location":"programs/interview-programs/#strings","title":"Strings","text":"stirng: convert each word first letter to capital form a sentence <pre><code>  string1 = 'tets hdsfhjsgfhgds'\n  let stringe = string1.split(' ').map(v =&gt; v[0].toUpperCase()+v.slice(0)).join(' ');\n  console.log(stringe)\n</code></pre> Given a string on second input indexes remove those values  <pre><code>  string1 = 'tets hdsfhjsgfhgds'\n  let stringe = string1.split(' ').map(v =&gt; v[0].toUpperCase()+v.slice(0)).join(' ');\n  console.log(stringe)\n</code></pre>"},{"location":"programs/interview-programs/#arrays","title":"Arrays","text":"sort <pre><code>const g = ['a', 'b', 'g', 'a']\ng.sort();\nconsole.log(g)\n\n// Create an Array\nconst points = [40, 100, 1, 5, 25, 10];\n\n// Sort the Array\npoints.sort(function(a, b){return a-b});\n</code></pre> flat an array <pre><code>const arr =[1,3,4,[3,4,5,[4,6,3]]];\nconst arr2 = [];\n\n// using flat\n  //  arr2 = arr.flat(3);\n\n// not using pre-defined\n  function flatArray(data){\n    for(var i=0;i&lt;data.length;i++){\n      if(Array.isArray(data[i])){\n        flatArray(data[i])\n      } else {\n        arr2.push(data[i]);\n      }\n    }\n  }\n  flatArray(arr);\n  console.log(arr2);\n</code></pre> 1. remove duplicates without using set     1.using foreach and includes() method.     2.using filter to get index of each element to match with current index      3.Remove duplicates in without using predefine methods  <pre><code>let data = [3, 5, , 1, 1, 1, 1, 2, 3];\nconst filteredData = data.filter((v, i) =&gt; {\n  return data.indexOf(v) === i;\n});\nconsole.log(filteredData);\nconst removeZero = data.filter((v) =&gt; {\n  return v !== 1;\n});\nconsole.log(removeZero);\nconst nData = [1, 2, 2, 1, 2, 3, 1];\nconst z = [...new Set(nData)];\nconsole.log(z);\n</code></pre> Map to add how many ele&gt; <pre><code>  const a = new Map();\ndata.forEach((r) =&gt; {\n  if (a.has(r)) {\n    let d = a.get(r);\n    a.set(r, ++d);\n  } else a.set(r, 1);\n});\nfor (let [k, o] of a) {\n  console.log(k, o);\n}\n</code></pre> Given a object of Arrays return each values which are not duplicated    1.using Object.values(object).flat u can get flat array   2.using reduce or foreach count each value and have it in object   3.using filter compare flat values with count values if taht ele is 1 then return taht array    <pre><code>\n</code></pre>"},{"location":"programs/interview-programs/#objects","title":"Objects","text":""},{"location":"react/plan/","title":"Roadmap","text":""},{"location":"react/plan/#_1","title":"Roadmap","text":"<p>React JSX</p> <pre><code>Akshay saini JS\nUI websites\nTypescript\nReact\n    structure\n    routing\n    hooks -&gt; useState(),useEffect(),useContext(),useReducer(),\n            useCallback(),useMemo(),React.memo, useRef()\n    redux-&gt; thunk,persist,saga,\n    RTL-Jest \nnextJS    \nexprexxJS\nMongoDB\nJS DSA\n</code></pre>"},{"location":"react/react/","title":"React","text":"<p>For note card</p>"},{"location":"react/react/#_1","title":"React","text":"<p>React JSX</p> <ul> <li> <p>** in return if it is single line we can omit () **</p> </li> <li> <p>Scenario: in return if it is single line we can omit () </p> </li> <li> <p>Use Case:  .</p> </li> </ul>"},{"location":"typescript/typescript/","title":"TypeScript Features","text":"<p>TypeScript is a superset of JavaScript that provides static typing, modern programming features, and enhanced tooling for scalable application development. Below is a list of its key features:</p>"},{"location":"typescript/typescript/#1-type-annotations","title":"1. Type Annotations","text":"<p>Allows developers to explicitly define variable, function, and return types for improved code clarity and debugging.</p>"},{"location":"typescript/typescript/#2-interfaces","title":"2. Interfaces","text":"<p>Provides a way to define the structure of objects, ensuring that they follow a specific shape or contract.</p>"},{"location":"typescript/typescript/#3-classes-and-inheritance","title":"3. Classes and Inheritance","text":"<p>Supports object-oriented programming concepts like classes, inheritance, and access modifiers (<code>public</code>, <code>private</code>, <code>protected</code>).</p>"},{"location":"typescript/typescript/#4-generics","title":"4. Generics","text":"<p>Enables reusable and type-safe components or functions that work with a variety of data types.</p>"},{"location":"typescript/typescript/#5-enums","title":"5. Enums","text":"<p>Defines a set of named constants for better code readability and management.</p>"},{"location":"typescript/typescript/#6-type-aliases","title":"6. Type Aliases","text":"<p>Allows you to create custom names for types to simplify and improve code readability.</p>"},{"location":"typescript/typescript/#7-modules","title":"7. Modules","text":"<p>Supports modular programming by enabling code splitting and importing/exporting functionality.</p>"},{"location":"typescript/typescript/#8-type-inference","title":"8. Type Inference","text":"<p>Automatically infers types based on the assigned values or return values, reducing the need for explicit annotations.</p>"},{"location":"typescript/typescript/#9-union-and-intersection-types","title":"9. Union and Intersection Types","text":"<p>Provides the ability to combine multiple types using union (<code>|</code>) or intersection (<code>&amp;</code>) operators.</p>"},{"location":"typescript/typescript/#10-decorators","title":"10. Decorators","text":"<p>Offers experimental support for metadata annotations on classes, methods, and properties for advanced scenarios like dependency injection.</p>"},{"location":"typescript/typescript/#11-access-modifiers","title":"11. Access Modifiers","text":"<p>Introduces visibility control for class members using <code>public</code>, <code>private</code>, and <code>protected</code> modifiers.</p>"},{"location":"typescript/typescript/#12-static-typing","title":"12. Static Typing","text":"<p>Adds static typing to JavaScript, helping catch errors at compile time rather than runtime.</p>"},{"location":"typescript/typescript/#13-readonly-modifier","title":"13. Readonly Modifier","text":"<p>Ensures that properties cannot be modified after their initial assignment.</p>"},{"location":"typescript/typescript/#14-utility-types","title":"14. Utility Types","text":"<p>Provides built-in types like <code>Partial</code>, <code>Pick</code>, <code>Omit</code>, and <code>Readonly</code> to simplify type transformations.</p>"},{"location":"typescript/typescript/#15-mapped-types","title":"15. Mapped Types","text":"<p>Allows the creation of new types by transforming existing types.</p>"},{"location":"typescript/typescript/#16-namespaces","title":"16. Namespaces","text":"<p>Supports organizing and encapsulating code within a namespace to prevent global scope pollution.</p>"},{"location":"typescript/typescript/#17-advanced-type-features","title":"17. Advanced Type Features","text":"<p>Includes features like conditional types, keyof operator, type guards, and type assertions for flexible and complex type handling.</p>"},{"location":"typescript/typescript/#18-null-and-undefined-handling","title":"18. Null and Undefined Handling","text":"<p>Offers strict null checking and features like <code>strictNullChecks</code> for safer code execution.</p>"},{"location":"typescript/typescript/#19-tooling-support","title":"19. Tooling Support","text":"<p>Integrates seamlessly with editors like VS Code, providing features like autocompletion, real-time error checking, and refactoring.</p>"},{"location":"typescript/typescript/#20-backward-compatibility","title":"20. Backward Compatibility","text":"<p>Compiles TypeScript into plain JavaScript, ensuring compatibility with existing JavaScript environments.</p> <p>TypeScript's rich set of features makes it a powerful tool for building maintainable and scalable applications.</p>"}]}